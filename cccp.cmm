#include <stdio.hmm>
#include <stdlib.hmm>
#include <string.hmm>
#include <ctype.hmm>
#include "./type.hmm"
#include "./difinition.hmm"
#include "./including.hmm"

#define INPUTSIZE 50      //単語のマックスサイズ
#define ARGSIZE 5         //マクロの引数数。内一つはnull用
#define TABLESIZE 20      //definitionテーブルのサイズ
#define INDEPTHSIZE 10    //includeの入れ子サイズ
#define INCLUDENAME 20    //includeのファイル名の大きさ
#define IFDEPTH 10        //ifの入れ子の深さ


unsigned char[] is_idchar;                  // 0~9 a~z A~Z
unsigned char[] is _idstart;                // a~z A~Z
unsigned char[] is_hor_space;               // ' ' \t \v \f \r
unsigned char[] is_space;                   // ' ' \t \v \f \n \r
public definition[] deftable=array(TABLESIZE);  //deftableの初期化
public filelist[] incdepth=array(INDEPTHSIZE); //includeのdepthの初期化
FILE fd;                                    //入力ファイル
FILE op;                                    //出力ファイル
unsigned char[] ipbuf=array(INPUTSIZE);     //入力ファイル用バッファ
char[] word;                                //単語用バッファ
boolean eofflag=false;                      //EOF用フラグ
int[] ifdepth=array(IFDEPTH);               //ifの入れ子用スタック
int sp=0;                                   //ifdepth用スタックポインタ
int linenum=1;                              //行番号
int byte=0;                                 //byte数



//is_idchar is_idstart is_hor_space is_spaceの初期化
void initialize_char_syntax(){
  int i;
  is_idchar=malloc(256);
  is_idstart=malloc(256);
  is_hor_space=malloc(256);
  is_space=malloc(256);


  //a~z A~Zの初期化
  for(i='a';i<='z';i++){
    is_idchar[i]=1;
    is_idstart[i]=1;
    is_idchar[i-'a'+'A']=1;
    is_idstart[i-'a'+'A']=1;
  }

  //0~9の初期化
  for(i=0;i<=9;i++){
    is_idchar[i]=1;
  }

  //is_hor_spaceの初期化
  is_hor_space[' ']=1;
  is_hor_space[\t]=1;
  is_hor_space[\v]=1;
  is_hor_space[\f]=1;
  is_hor_space[\r]=1;

  //is_spaceの初期化
  is_space[' ']=1;
  is_space[\t]=1;
  is_space[\v]=1;
  is_space[\v]=1;
  is_space[\f]=1;
  is_space[\n]=1;
  is_space[\r]=1;
}



int enterlcnt=0;         //改行の数
char nextlch='\0';      //getL()用の次文字
// \\nを無視する１文字入力
char getL(){
  char lch;     //今の文字

  //次の文字がからではなく'\\'でない（次の文字が持っている）
  if(nextlch!='\0' && nextlch!='\\'){
    lch=nextlch;    //今の文字は次の文字をみる
    nextlch='\0';   //次の文字を空にする
    byte=byte+sizeof(char); //見た文字の数だけbyteを加算
    return lch;     //今の文字を返す
  }

  //次の文字が'\\'である
  else if(nextlch=='\\'){
    lch=nextlch;    //今の文字は次の文字を見る
    nextlch='\0';   //次の文字を空にする
    byte=byte+sizeof(char); //見た文字の数だけbyteを加算
  }

  //次の文字が空である
  else{
    lch=fgetc(fd);  //今の文字を入力
    byte=byte+sizeof(char); //見た文字の数だけbyteを加算
  }

  //今の文字が'\\'である
  while(lch=='\\'){

    //eofチェック
    if(!feof(fd)){
      nextlch=fgetc(fd);  //次の文字を入力
    }
    //eofだった
    else{
      eofflag=true; //eofflagをオン
      return '\n';  //改行を返す
    }

    //次の文字が改行である
    if(nextlch=='\n'){
      linenum=linenum+1;  //行数をインクリメント
      if(!feof(fd)){

        //以降' 'である間は続く
        //結合時に' 'は削除して結合するため
        do{
          lch=fgetc(fd);  //次の文字のさらに次を見る
          byte=byte+sizeof(char);
          if(feof(fd)){
            eofflag=true;
            return '\n';
          }
        }while(lch==' ');
      }
      else{
        eofflag=true;
        return '\n';
      }

      enterlcnt=enterlcnt+1;  //改行の数だけcntを増やす
      nextlch='\0';           //次の文字を空にする
    }

    //次の文字が改行でないなら今の文字を返す
    else
      return lch;
  }

  //今の文字が改行なら行数インクリメント
  if(lch=='\n')
    linenum=linenum+1;

  return lch;
}



int enterhcnt=0;        //改行の数
char nexthch='\0';      //getH()用の次文字
boolean sentense=false; //"..."または'x'用のフラグ
// コメントを削除する１文字入力
char getH(){
  char hch;           //今の文字
  boolean commentflag=false;  //コメントである時のフラグ

  //次の文字が空でない
  if(nexthch!='\0'){
    hch=nexthch;    //今の文字は次の文字を見る
    nexthch='\0';   //次の文字を空に
    return hch;     //今の文字を返す
  }

  hch=getL();       //今の文字入力

  //文字列である
  if(sentense)
    return hch;     //そのまま返す


  //今の文字が'/'である
  while(hch=='/'){
    nexthch=getL();   //次の文字を入力

    //eofならbreak
    if(eofflag)
      break;

    //次の文字が'/'である
    if(nexthch=='/'){
      nexthch='\0';  //次の文字を空にする

      //改行まで飛ばす
      while(hch!='\n'){
        hch=getL();
        if(eofflag)
          return hch;   //eofであるから改行を返すはず
      }
      enterhcnt=enterhcnt+1;  改行の数だけインクリメント
    }

    //次の文字が'*'だった
    else if(nexthch=='*'){
      nexthch='\0';   //次の文字を空にする
      commentflag=true;  //コメントフラグをオン

      //コメントフラグがオンの間飛ばす
      while(commentflag){

        //今の文字が'*'出ない間
        while(hch!='*'){

          //改行ならインクリメント
          if(hch=='\n')
            enterhcnt=enterhcnt+1;
          hch=getL();
          if(eofflag){
            return hch; //eofであるから改行を返すはず
          }
        }
        hch=getL(); //'*'の次の文字を入力
        if(eofflag){
          return hch; //eofであるから改行を返すはず
        }

        //'*'の次の文字が'/'ならコメント終了
        if(hch=='/')
           commentflag=false;
      }
    }

    //次の文字がただの文字だった
    else
      return hch;

    //コメント後にコメントが来ることを予期してもう一周する
    hch=getL();
    if(eofflag)
      return hch;
  }

  return hch;     //コメントでもなんでもないのでそのまま返す
}



char nextwch='\0';        //次の文字を取得する
boolean wordflag=false;   //今の文字と次の文字がアルファベットならtrue
boolean wordspace=false;  //次の文字が' 'になった時true
boolean argspace=false;   //引数の解析時のフラグ
boolean linehead=true;    //行の先頭ならtrue
//今の文字と次の文字を同時にとり、記号と単語を分ける
//返り値は今の文字だが呼び出した関数は主にフラグをみる
char getWord(){
  char wch;     //今の文字

  //次の文字が空でなかったら今の文字に入れる
  if(nextwch!='\0'){
    wch=nextwch;
    nextwch='\0';
  }

  //次の文字が空だったら今の文字を取得
  else{
    wch=getH();
  }

  nextwch=getH();   //次の文字取得

  //今の文字が 0~9 a~z A~Z '.'のどれかか
  if(isAlnum(wch) || wch=='.'){
    linehead=false;       //行の先頭フラグをオン
    wordflag=true;        //単語であるのでフラグをオン

    //次の文字が記号なら
    if(!isAlnum(nextwch) && nextwch!='.'){
      wordflag=false;     //フラグをオフ
    }
  }

  //今の文字が' 'なら
  else if(wch==' ' && !argspace){
    //行の先頭ならそのまま' 'を返す
    if(linehead){
      wordspace=false;
        return wch;
    }

    //フラグがオンなら１つだけ' 'を返して他の' 'は飛ばす
    else if(wordspace){
      wordspace=false;
      while(nextwch==' ')
        nextwch=getH();
      return wch;
    }
  }

  //今の文字が'\"'なら
  else if(wch=='\"'){
    if(!sentense)
      sentense=true;
    else
      sentense=false;
  }

  //今の文字が記号ならフラグをオフ
  else{
    linehead=false;
    wordflag=false;
  }

  //次の文字が' 'ならフラグをオン
  if(nextwch==' ')
    wordspace=true;

  return wch;
}



//コメントまたは\\n時の改行の数だけ改行する
//返り値はipbufの位置
int entercount(){
  int i;
  for(i=0;i<(enterhcnt+enterlcnt);i=i+1){
    ipbuf[i]='\n';
  }
  enterlcnt=0;
  enterhcnt=0;
  return i;
}


boolean lexflag=false;
//字句解析
int lexical(){
  int bufn=0;                   //現在文字位置
  int wordn=0;                   //単語の位置
  char buf;                     //入力文字

  word=malloc(sizeof(char)*INPUTSIZE);

  buf=getWord();

  //スペースか改行か記号まで文字を取り出す
  //ただし'.'は含めておく
  while(wordflag || sentense){
    ipbuf[bufn]=buf;
    word[wordn]=buf;
    bufn=bufn+1;
    wordn=wordn+1;
    buf=getWord();
  }

  //改行で終わったなら行先頭フラグを立てる
  if(buf=='\n'){
    bufn=entercount();
    sentense=false;
    linehead=true;
  }


  ipbuf[bufn]=buf;
  bufn=bufn+1;
  ipbuf[bufn]='\0';
  word[wordn]=buf;
  wordn=wordn+1;
  word[wordn]='\0';

  int wordlen=strLen(word);

  //字句解析
  if(lexflag){
    if(strCmp(word,"Edefine")==0){
      return T_EDEFINE;
    }
    else if(strCmp(word,"Sdefine")==0){
      return T_SDEFINE;
    }
    else if(strCmp(word,"include")==0){
      return T_INCLUDE;
    }
    else if(strCmp(word,"else")==0){
      return T_ELSE;
    }
    else if(strCmp(word,"ifdef")==0){
      return T_IFDEF;
    }
    else if(strCmp(word,"ifndef")==0){
      return T_IFNDEF;
    }
    else if(strCmp(word,"elseifdef")==0){
      return T_ELSEIFDEF;
    }
    else if(strCmp(word,"elseifndef")==0){
      return T_ELSEIFNDEF;
    }
    else if(strCmp(word,"endif")==0){
      return T_ENDIF;
    }
    else if(strCmp(word,"undef")==0){
      return T_UNDEF;
    }
  }

  if(word[0]=='\'' && word[wordlen-1]=='\''){
    return T_MOJI;
  }
  else if(word[0]=='\"' && word[wordlen-1]=='\"'){
    return T_MOJI;
  }
  return T_OTHER;
}


//' 'をスキップする関数
//返り値は単語タイプ
int skipspace(){
  int type;
  lexical();
  while(strCmp(word," ")==0)
    type=lexical();
  return type;
}

char[] lexarg(){
  int parentcnt=0;
  char[] arg;
  arg=malloc(sizeof(char)*ARGSIZE);

  lexical();
  arg=strCpy(arg,"\0");
  while(true){
    if(strCmp(word,",")==0 && parentcnt==0)
      break;
    if(strCmp(word,")")==0 && parentcnt==0)
      break;
    if(strCmp(word,"\n")==0 || eofflag){
      //T_ERROR
      break;
    }
    if(strCmp(word,"(")==0)
      parentcnt=parentcnt+1;
    else if(strCmp(word,")")==0)
      parentcnt=parentcnt-1;
    arg=strCat(arg,word);
    lexical();
  }
  return arg;
}


//(x,y)とかの引数の取り出し
//返り値は引数
int narg;     //引数数
char[][] getArg(){
  char[][] args;      //引数を持つ配列
  narg=0;             //引数の数
  argspace=true;

  args=malloc(sizeof(char[])*ARGSIZE);

  lexical();
  if(strCmp(word,"(")==0){
    args[narg]=lexarg();
    narg=narg+1;
    while(strCmp(word,",")==0){
      args[narg]=lexarg();
      narg=narg+1;
    }
    if(strCmp(word,")")!=0)
      //error
      narg=narg;
  }

  args[narg]=null;
  argspace=false;

  return args;
}



//定義本体の取得
//定義本体の引数の位置やマクロ名の入子を処理する
//返り値は定義本体
char[] getDef(char[] mname,char[][] arg){
  char[] buffer=malloc(sizeof(char)*INPUTSIZE);
  int wordn=0;          //単語の出現番号、引数の出現時に使う
  char[] submacro;      //途中で見つけたマクロ名を保持
  char[][] subarg;      //定義本体中のマクロの引数
  int subnarg=narg;     //引数数を保持

  skipspace();

  while(word[0]!='\n'){

    //引数と同じならリストに登録
    int i=0;
    for(i=0;i<subnarg;i=i+1){
      if(strCmp(arg[i],word)==0){
        if(makelist(mname,i,wordn)==-1)
          return null;
      }
    }

    //引数でないならマクロ名かどうかを比較
    if(i==subnarg){
      int n=searchdef(word);
      if(n!=-1){
        submacro=word;
        if(deftable[n].narg==0){
          subarg=malloc(sizeof(char[])*1);
          subarg[0]=null;
        }
        else{
          subarg=getArg();
        }
        ipbuf=replacedef(submacro,subarg);
      }
    }

    buffer=strCat(buffer,ipbuf);
    lexical();
    wordn=wordn+1;
  }
  buffer=strCat(buffer,"\0");
  return buffer;
}




//マクロ名を登録する前の前処理
//返り値はマクロの引数の多次元配列
char[] macroname;
char[][] do_makeMname(){
  int type=0;   //文字タイプ
  char[][] args;

  //マクロの定義ができずに終了
  if(feof(fd))
    return null;

  type=skipspace();
  macroname=word;


  //文字タイプがただの文字かどうか
  if(type==T_OTHER){
    //マクロ名の最初の文字がアルファベットかどうか
    if(isAlpha(word[0])){
      args=getArg();           //引数の配列
      int i=0;
      for(i=0;i<narg;i=i+1){
        //引数の最初の文字がアルファベットかどうか
        if(!isAlpha(args[i][0]))
          //引数名不可
          return null;
      }

      if(makemacro(macroname,narg)==-1) //マクロ名の登録
        return null;
    }
    else{
      //アルファベットから始まらないマクロ名不可
      return null;
    }
  }
  else{
    //特殊なマクロ名不可
    return null;
  }
  return args;
}


//#Edefineを見つけた
int do_Edefine(){
  char[][] args;               //引数

  args=do_makeMname();
  if(args==null)
    return -1;

  char[] def=malloc(sizeof(char)*INPUTSIZE);  //定義本体用バッファ


  def=getDef(macroname,args);             //定義本体取り出し
  if(def==null)         //定義本体がないなら
    return -1;

  int i=0;
  int cnt=1;
  if(def[0]=='('){
    for(i=1;def[i]!='\0';i=i+1){
      if(def[i]=='(')
        cnt=cnt+1;
      else if(def[i]==')')
        cnt=cnt-1;

      if(cnt==0)
        break;
    }
    if(def[i+1]!='\0')
      return -1;
  }
  else
    return -1;

  if(makedef(macroname,def)==-1)  //定義本体の登録
    return -1;
  return 0;
}


int do_Sdefine(){
  char[][] args;
  args=do_makeMname();
  if(args==null)
    return -1;

  char[] def=malloc(sizeof(char)*INPUTSIZE);  //定義本体用バッファ

  def=getDef(macroname,args);             //定義本体取り出し
  if(def==null)         //定義本体がないなら
    return -1;

  if(makedef(macroname,def)==-1)  //定義本体の登録
    return -1;
  return 0;
}


int do_include(){
  int type;
  char[] includename=malloc(sizeof(char)*INCLUDENAME);

  type=skipspace();
  if(type==T_MOJI){
    int i=0;
    for(i=1;word[i]!='\"';i=i+1)
      includename[i-1]=word[i];
  }
  else if(word[0]=='<'){
    lexical();
    while(word[0]!='>'){
      includename=strCat(includename,word);
      lexical();
    }
  }
  saveincdepth(linenum,byte);
  isp=makeincdepth(includename);
  fd=fopen(incdepth[isp].name,"r");
  byte=0;
  linenum=0;
  return 0;
}


int do_ifdef(int con){
  if(ifdepth[sp]==1){
    sp=sp+1;
    if(con==1){
      ifdepth[sp]=1;
    }
    else{
      ifdepth[sp]=0;
    }
  }
  else{
    sp=sp+1;
    ifdepth[sp]=0;
  }
  return 0;
}


int do_ifndef(int con){
  if(ifdepth[sp]==1){
    sp=sp+1;
    if(con==0){
      ifdepth[sp]=1;
    }
    else{
      ifdepth[sp]=0;
    }
  }
  else{
    sp=sp+1;
    ifdepth[sp]=0;
  }
  return 0;
}


int do_else(){
  if(ifdepth[sp-1]==1){
    if(ifdepth[sp]==1){
      ifdepth[sp]=0;
    }
    else{
      ifdepth[sp]=1;
    }
  }
  else{
    ifdepth[sp]=0;
  }
  return 0;
}


int do_elseifdef(int con){
  if(ifdepth[sp-1]==1){
    if(ifdepth[sp]==1){
      ifdepth[sp]=0;
    }
    else{
      if(con==1){
        ifdepth[sp]=1;
        ifdepth[sp-1]=0;
      }
      else{
        ifdepth[sp]=0;
      }
    }
  }
  else{
    ifdepth[sp]=0;
  }
  return 0;
}


int do_elseifndef(int con){
  if(ifdepth[sp-1]==1){
    if(ifdepth[sp]==1){
      ifdepth[sp]=0;
    }
    else{
      if(con==0){
        ifdepth[sp]=1;
        ifdepth[sp-1]=0;
      }
      else{
        ifdepth[sp]=0;
      }
    }
  }
  else{
    ifdepth[sp]=0;
  }
  return 0;
}


int do_endif(){
  ifdepth[sp]=0;
  sp=sp-1;
  return 0;
}


int conditioncheck(){
  skipspace();
  int n=searchdef(word);
  if(n>-1)
    return 1;
  return 0;
}


int do_undef(){
  skipspace();
  if(deletedef(word)==-1)
    return -1;
  return 0;
}


void do_error(){

}


void construction(){

}


public int main(int argc,char[][] argv){

  char[] bufer;         //マクロ展開時用バッファ
  int linen=1;            //行番号
  char buf;             //現在文字
  int bufn;             //現在文字位置
  int type;             //字句解析タイプ
  int condition;

  initialize_char_syntax();
  fd=fopen(argv[1],"r");       //入力ファイル

  char[][] subarg;
  char[] submacro;
  ifdepth[sp]=1;    //ifdepthの最初は常に１

  //入力ファイル読み込み
  while(!feof(fd)){
    type=lexical()            //入力行の単語のタイプ

    //タイプがEdefineなら
    if(type==T_EDEFINE){

      //その行分の改行の出力

      do_Edefine();
    }
    else if(type==T_SDEFINE){
      do_Sdefine();
    }
    else if(type==T_INCLUDE){
      do_include();
    }
    else if(type==T_ELSE){
      do_else();
    }
    else if(type==T_IFDEF){
      do_ifdef();
    }
    else if(type==T_IFNDEF){
      do_ifndef();
    }
    else if(type==T_ELSEIFDEF){
      do_elseifdef();
    }
    else if(type==T_ELSEIFNDEF){
      do_elseifndef();
    }
    else if(type==T_ENDIF){
      do_endif();
    }
    else if(type==T_UNDEF){
      do_undef();
    }
    else if(type==T_MOJI){

      //何も考えずに出力

    }
    else if(type=T_OTHER){

      //マクロ名かどうかの探索またはoutput出力

    }

  }
  fclose(fd);


}

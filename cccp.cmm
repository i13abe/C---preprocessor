#include <stdio.hmm>
#include <stdlib.hmm>
#include <string.hmm>
#include <ctype.hmm>
#include "type.hmm"
#include "definition.hmm"
#include "including.hmm"
#include "condition.hmm"

#define INPUTSIZE 50                            //単語のマックスサイズ
#define ARGSIZE 5                               //マクロの引数数。内一つはnull用
#define TABLESIZE 200                           //definitionテーブルのサイズ
#define INDEPTHSIZE 10                          //includeの入れ子サイズ
#define INCLUDENAME 50                          //includeのファイル名の大きさ
#define PATHNUM 10                              //pathの保持数
#define IFDEPTH 10                              //ifdefなどの入れ子の深さ



public definition[] deftable=array(TABLESIZE);  //deftableの初期化
public filelist[] incdepth=array(INDEPTHSIZE);  //incdepthの初期化
public ifelse[] iftable=array(IFDEPTH);         //ifdepthの初期化
FILE fd;                                        //入力ファイル
FILE op;                                        //出力ファイル
char[] ipbuf=array(INPUTSIZE*2);                //入力ファイル用バッファ
char[] word;                                    //単語用バッファ
boolean eofflag=false;                          //EOF用フラグ
int sp=0;                                       //ifdepth用スタックポインタ
int isp=0;                                      //includeテーブルのスタックポインタ
int linenum=1;                                  //行番号
int bytel=0;                                    //下位16bitのbyte数
int byteh=0;                                    //上位16bitのbyte数
char[][] incpath;                               //includeのpathを保持
int ipsp=0;                                     //incpathのスタックポインタ


//エラー強制終了
void do_error(char[] ers){
  printf("error:%s:line %d:",incdepth[isp].name,linenum);//エラーファイル名と行番号出力
  puts(ers);                                            //エラーを出力
  exit(1);                                              //強制終了
}



//byteh,bytelの加算、オーバーフローに対応する
void byteplus(){
  if(bytel==32767){                   //bytelがオーバーフロー寸前
    byteh=byteh+sizeof(char);         //bytehを加算
    bytel=0;                          //bytelを初期化
  }
  else{                               //bytelがまだ加算可能
    bytel=bytel+sizeof(char);         //bytelを加算
  }
}



int enterlcnt=0;                      //\\nの改行の数
char nextlch='\0';                    //getL()用の次文字

// \\nを無視する１文字入力
char getL(){
  char lch;                           //今の文字

  if(nextlch!='\0' && nextlch!='\\'){ //次の文字が空ではなく'\\'でないなら（次の文字が何か持っている）
    lch=nextlch;                      //今の文字は次の文字をみる
    nextlch='\0';                     //次の文字を空にする
    byteplus();                       //見た文字の数だけbyteを加算
    return lch;                       //今の文字を返す
  }
  else if(nextlch=='\\'){             //次の文字が'\\'なら
    lch=nextlch;                      //今の文字は次の文字を見る
    nextlch='\0';                     //次の文字を空にする
    byteplus();                       //見た文字の数だけbyteを加算
  }
  else{                               //次の文字が空なら
    if(!feof(fd)){                    //eofでないなら
      lch=fgetc(fd);                  //今の文字を入力
      byteplus();                     //見た文字の数だけbyteを加算
    }
    else{                             //eofなら
      eofflag=true;                   //eofflagをオン
      return '\n';                    //eof時は改行を返す
    }
  }

  while(lch=='\\'){                   //今の文字が'\\'なら
    if(!feof(fd)){                    //eofでないなら
      nextlch=fgetc(fd);              //次の文字を入力
    }
    else{                             //eofなら
      eofflag=true;                   //eofflagをオン
      return '\n';                    //eof時は改行を返す
    }

    if(nextlch=='\n'){                //次の文字が改行なら
      byteplus();
      linenum=linenum+1;              //行数をインクリメント
      if(!feof(fd)){                  //eofでないなら
        do{                           //結合時に' 'は削除して結合するため、以降' 'である間は続く
          lch=fgetc(fd);              //次の文字のさらに次を見る
          byteplus();                 //見た文字の数だけbyteを加算
          if(feof(fd)){               //eofなら
            eofflag=true;             //eofflagをオン
            return '\n';              //eof時は改行を返す
          }
        }while(lch==' ');             //' 'ならループ
      }
      else{                           //eofなら
        eofflag=true;                 //eofflagをオン
        return '\n';                  //eof時は改行を返す
      }
      enterlcnt=enterlcnt+1;          //改行の数だけcntを増やす
      nextlch='\0';                   //次の文字を空にする
    }
    else                              //次の文字が改行でないなら
      return lch;                     //今の文字を返す
  }

  return lch;                         //今の文字を返す
}



int enterhcnt=0;                      // /*~*/の中の改行の数
char nexthch='\0';                    //getH()用の次文字
boolean sentense=false;               //"..."用のフラグ
boolean sentensec=false;              //'x'用のフラグ
boolean backflag=false;               //'\\'用のフラグ
boolean backsent=false;               //'\"'と'\''用のフラグ

// コメントを削除する１文字入力
char getH(){
  char hch;                           //今の文字
  boolean commentflag=false;          //コメントである時のフラグ

  if(nexthch!='\0'){                  //次の文字が空でないなら
    hch=nexthch;                      //今の文字に次の文字を代入
    nexthch='\0';                     //次の文字を空に
    return hch;                       //今の文字を返す
  }

  hch=getL();                         //今の文字取得

  if(hch=='\"'){                      //今の文字が'\"'なら
    if(!sentense)                     //sentenseがオンでないなら
      sentense=true;                  //sentenseをオン
    else
      sentense=false;                 //sentenseをオフ
  }

  if(hch=='\''){                      //今の文字が'\''なら
    if(!sentensec)                    //sentensecがオンでないなら
      sentensec=true;                 //sentensecをオン
    else
      sentensec=false;                //sentensecをオフ
  }

  if(sentense || sentensec)           //sentenseまたはsentensecがオンなら
    return hch;                       //そのまま今の文字を返す

  while(hch=='/'){                    //今の文字が'/'なら
    nexthch=getL();                   //次の文字取得
    if(eofflag)                       //eofflagがオンなら
      break;                          //break

    if(nexthch=='/'){                 //次の文字が'/'なら
      nexthch='\0';                   //次の文字を空にする
      while(hch!='\n'){               //改行まで飛ばす
        hch=getL();                   //１文字取得
        if(eofflag)                   //eofflagがオンなら
          return hch;                 //eofであるから改行を返すはず
      }
      break;                          //ループを抜ける(上手くいっていれば今の文字は改行のはず)
    }
    else if(nexthch=='*'){            //次の文字が'*'なら
      nexthch='\0';                   //次の文字を空にする
      commentflag=true;               //commentflagをオン
      while(commentflag){             //commentflagがオンの間
        while(hch!='*'){              //今の文字が'*'出ない間
          if(hch=='\n'){              //改行なら
            linenum=linenum+1;        //行数を加算
            enterhcnt=enterhcnt+1;    //改行数を加算
          }
          hch=getL();                 //１文字取得
          if(eofflag){                //eofflagがオンなら
            return hch;               //eofであるから改行を返すはず
          }
        }
        hch=getL();                   //'*'の次の文字を取得
        if(eofflag){                  //eofflagがオンなら
          return hch;                 //eofであるから改行を返すはず
        }

        if(hch=='/')                  //'*'の次の文字が'/'なら
           commentflag=false;         //コメント終了 commentflagをオフ
      }
    }
    else                              //次の文字がただの文字だった
      return hch;                     //今の文字を返す

    hch=getL();                       //コメント後にコメントが来ることを予期してもう一周する
    if(eofflag)                       //eofflagがオンなら
      return hch;                     //eofであるから改行を返すはず
  }

  return hch;                         //今の文字を返す
}



char nextwch='\0';                        //getWord()用の次の文字
boolean wordflag=false;                   //今の文字と次の文字がアルファベットかどうかのフラグ
boolean wordspace=false;                  //次の文字が' 'かどうかのフラグ
boolean argspace=false;                   //引数の解析時用のフラグ
boolean linehead=true;                    //行の先頭かどうかのフラグ

//今の文字と次の文字を同時にとり、記号と単語を分ける
//返り値は今の文字だが呼び出した関数は主にフラグをみる
char getWord(){
  char wch;                                                         //今の文字

  if(nextwch!='\0'){                                                //次の文字が空でないなら
    wch=nextwch;                                                    //今の文字に次の文字を代入
    nextwch='\0';                                                   //次の文字を空にする
  }
  else{                                                             //次の文字が空なら
    wch=getH();                                                     //今の文字取得
  }

  nextwch=getH();                                                   //次の文字取得

  if(sentense && nextwch!='\"'){                                    //sentenseがオンで最初の'\"'でない
      backflag=false;                                               //backflagをオフ
      backsent=false;                                               //backsentをオフ
      sentensec=false;                                              //sentensecをオフ
      if(wch=='\\' && nextwch=='\\'){                               //"\\"という表記なら
        backflag=true;                                              //backflagをオン
      }
      wordflag=true;                                                //wordflagをオン
      return wch;                                                   //今の文字を返す
  }

  if(sentensec && nextwch!='\''){                                   //sentensecがオンで最初の'\''でない
      backflag=false;                                               //backflagをオフ
      backsent=false;                                               //backsentをオフ
      sentense=false;                                               //sentenseをオフ
      if(wch=='\\' && nextwch=='\\'){                               //"\\"という表記なら
        backflag=true;                                              //backflagをオン
      }
      wordflag=true;                                                //wordflagをオン
      return wch;                                                   //今の文字を返す
  }

  if(isAlnum(wch) || wch=='.' || wch=='_'){                         //今の文字が 0~9 a~z A~Z '.' '_'のどれかなら
    linehead=false;                                                 //lineheadをオフ
    wordflag=true;                                                  //wordflagをオン
    if(!isAlnum(nextwch) && nextwch!='.' && nextwch!='_'){          //次の文字が記号なら
      if(nextwch=='\"' && !sentense)                                //終わりの'\"'なら
        wordflag=true;                                              //wordflagをオン
      else if(nextwch=='\'' && !sentensec)                          //終わりの'\''なら
        wordflag=true;                                              //wordflagをオン
      else                                                          //始まりの'\"'なら
        wordflag=false;                                             //wordflagをオフ
    }
  }
  else if(wch==' ' && !argspace){                                   //今の文字が' 'なら
    if(linehead){                                                   //行の先頭なら
      wordspace=false;                                              //wordspaceをオフ
        return wch;                                                 //今の文字を返す（スペース）
    }
    else if(wordspace){                                             //wordspaceがオンなら
      wordspace=false;                                              //wordspaceをオフ
      while(nextwch==' ')                                           //次の文字が空欄の間
        nextwch=getH();                                             //次の文字取得
      return wch;                                                   //今の文字を返す（スペース）
    }
  }
  else if(wch=='\"' || wch=='\''){                                  //今の文字が'\"'または'\''なら
    linehead=false;                                                 //lineheadをオフ
    if(sentense)                                                    //sentenseがオンなら
      wordflag=true;                                                //wordflagをオン
    else                                                            //sentenseがオフなら
      if(backsent){                                                 //backsentがオンなら
        wordflag=true;                                              //wordflagをオン
        backsent=false;                                             //backsentをオフ
      }
      else                                                          //backsentがオフなら
        wordflag=false;                                             //wordflagをオフ
  }
  else if(wch=='\''){                                               //今の文字が'\''なら
    linehead=false;                                                 //lineheadをオフ
    if(sentensec)                                                   //sentenseがオンなら
      wordflag=true;                                                //wordflagをオン
    else                                                            //sentenseがオフなら
      if(backsent){                                                 //backsentがオンなら
        wordflag=true;                                              //wordflagをオン
        backsent=false;                                             //backsentをオフ
      }
      else                                                          //backsentがオフなら
        wordflag=false;                                             //wordflagをオフ
  }
  else if(wch=='\\' && nextwch=='\"'){                             //"\""という表記なら
    if(backflag){                                                  //backflagがオンなら
      if(sentense)                                                 //sentenseがオンなら
        wordflag=false;                                            //wordflagをオフ
      else                                                         //sentenseがオフなら
        wordflag=true;                                             //wordflagをオン
    }
    else{                                                          //backflagがオフなら
      backsent=true;                                               //backsentをオン
      if(sentense)                                                 //sentenseがオンなら
        sentense=false;                                            //sentenseをオフ
      else{                                                        //sentenseがオフなら
        wordflag=true;                                             //wordflagをオフ
        sentense=true;                                             //sentenseをオン
      }
    }
  }
  else if(wch=='\\' && nextwch=='\''){                              //"\'"という表記なら
    if(backflag){                                                   //backflagがオンなら
      if(sentensec)                                                 //sentenseがオンなら
        wordflag=false;                                             //wordflagをオフ
      else                                                          //sentenseがオフなら
        wordflag=true;                                              //wordflagをオン
    }
    else{                                                           //backflagがオフなら
      backsent=true;                                                //backsentをオン
      if(sentensec)                                                 //sentenseがオンなら
        sentensec=false;                                            //sentenseをオフ
      else{                                                         //sentenseがオフなら
        wordflag=true;                                              //wordflagをオフ
        sentensec=true;                                             //sentenseをオン
      }
    }
  }
  else{                                                             //今の文字が記号なら
    linehead=false;                                                 //lineheadをオフ
    if(nextwch=='\"' && !sentense)                                  //終わりの'\"'なら
      wordflag=true;                                                //wordflagをオン
    else if(nextwch=='\'' && !sentensec)                            //終わりの'\''なら
      wordflag=true;                                                //wordflagをオン
    else                                                            //始まりの'\"'なら
      wordflag=false;                                               //wordflagをオフ
  }

  if(nextwch==' ')                                                  //次の文字が' 'なら
    wordspace=true;                                                 //wordspaceをオン

  return wch;                                                       //今の文字を返す
}



//コメントまたは\\n時の改行の数だけ改行する
//返り値はipbufの位置
int entercount(){
  int i;                                          //bufferの添字
  for(i=0;i<(enterhcnt+enterlcnt);i=i+1){         //改行の数だけループ
    ipbuf[i]='\n';                                //先頭から改行を代入
  }
  enterlcnt=0;                                    //改行数を初期化
  enterhcnt=0;                                    //改行数を初期化
  return i;                                       //現在のbufferの添字を返す
}



boolean lexflag=false;                            //'#'を見つけた時用のフラグ

//字句解析
int lexical(){
  int bufn=0;                                     //現在文字位置
  int wordn=0;                                    //単語の位置
  char buf;                                       //入力文字
  int wordlen;                                    //単語の文字数

  free(word);
  word=malloc(sizeof(char)*INPUTSIZE);            //単語の初期化

  buf=getWord();                                  //１文字取得

  while(wordflag){                                //スペースか改行か記号まで文字を取り出す（ただし'.'は含めておく）
    ipbuf[bufn]=buf;                              //ipbufに現在文字を代入
    word[wordn]=buf;                              //wordに現在文字を代入
    bufn=bufn+1;                                  //現在文字位置をインクリメント
    wordn=wordn+1;                                //現在単語位置をインクリメント
    buf=getWord();                                //文字取得
  }

  if(buf=='\n'){                                  //改行で終わったなら
    bufn=entercount();                            //entercount()を呼び出す
    sentense=false;                               //sentenseをオフ
    sentensec=false;                              //sentensecをオフ
    linehead=true;                                //lineheadをオン
  }

  ipbuf[bufn]=buf;                                //最後の１文字を代入
  bufn=bufn+1;                                    //現在文字位置をインクリメント
  ipbuf[bufn]='\0';                               //'\0'を代入
  word[wordn]=buf;                                //最後の１文字を代入
  wordn=wordn+1;                                  //現在単語位置をインクリメント
  word[wordn]='\0';                               //'\0'を代入
  if(word[0]=='\n'){                              //今の文字が改行なら
    linenum=linenum+1;                            //改行回数を加算
  }

  wordlen=strLen(word);                           //単語の文字数を取得

  if(lexflag){                                    //'#'があったなら
    if(strCmp(word,"define")==0){                 //"#define"なら
      return T_DEFINE;                            //T_DEFINEを返す
    }
    if(strCmp(word,"Edefine")==0){                //"#Edefine"なら
      return T_EDEFINE;                           //T_EDEFINEを返す
    }
    else if(strCmp(word,"Sdefine")==0){           //"#Sdefine"なら
      return T_SDEFINE;                           //T_SDEFINEを返す
    }
    else if(strCmp(word,"include")==0){           //"#include"なら
      return T_INCLUDE;                           //T_INCLUDEを返す
    }
    else if(strCmp(word,"else")==0){              //"#else"なら
      return T_ELSE;                              //T_ELSEを返す
    }
    else if(strCmp(word,"ifdef")==0){             //"#ifdef"なら
      return T_IFDEF;                             //T_IFDEFを返す
    }
    else if(strCmp(word,"ifndef")==0){            //"#ifndef"なら
      return T_IFNDEF;                            //T_IFNDEFを返す
    }
    else if(strCmp(word,"elifdef")==0){           //"#elseifdef"なら
      return T_ELSEIFDEF;                         //T_ELSEIFDEFを返す
    }
    else if(strCmp(word,"elifndef")==0){          //"#elseifndef"なら
      return T_ELSEIFNDEF;                        //T_ELSEIFNDEFを返す
    }
    else if(strCmp(word,"endif")==0){             //"#endif"なら
      return T_ENDIF;                             //T_ENDIFを返す
    }
    else if(strCmp(word,"undef")==0){             //"#undef"なら
      return T_UNDEF;                             //T_UNDEFを返す
    }
  }
  if(word[0]=='\'' && word[wordlen-1]=='\''){     //'x'なら
    return T_MOJI;                                //T_MOJIを返す
  }
  else if(word[0]=='\"' && word[wordlen-1]=='\"'){//"..."なら
    return T_MOJI;                                //T_MOJIを返す
  }
  return T_OTHER;                                 //ただの文字ならT_OTHERを返す
}



//' 'をスキップする関数
//返り値は単語タイプ
int skipspace(){
  int type;                                       //字句解析タイプ
  type=lexical();                                 //単語取得
  while(strCmp(word," ")==0){                     //" "の間ループ
    type=lexical();                               //単語取得
  }
  return type;                                    //typeを返す
}



char[][] getArg();
boolean naflag=false;                             //引数が空フラグ
//引数用字句解析
//引数の場合" "や()の数を保存するため、字句解析を分けた
char[] lexarg(){
  int parentcnt=0;                                //()の数
  char[] arg;                                     //引数文字列
  arg=malloc(sizeof(char)*ARGSIZE*10);            //引数文字列の初期化
  char[][] subarg;                                //引数用配列

  lexical();                                      //単語取得
  arg=strCpy(arg,"\0");                           //引数の先頭に'\0'を代入
  while(true){                                    //breakまでループ
    if(strCmp(word,",")==0 && parentcnt==0)       //()がなく、単語が','なら
      break;                                      //1つの引数の終わり
    if(strCmp(word,")")==0 && parentcnt==0)       //()がなく、単語が')'なら
      break;                                      //引数の終わりの')'
    if(strCmp(word,"\n")==0 || eofflag){          //eofまたは改行なら
      do_error("マクロの引数の記述が正しくない");      //引数が途中で切れているエラー
    }
    if(strCmp(word,"(")==0)                       //'('なら
      parentcnt=parentcnt+1;                      //parentcntを加算
    else if(strCmp(word,")")==0)                  //')'なら
      parentcnt=parentcnt-1;                      //parentcntを減算
    int n=searchdef(word);                        //マクロ名を探索
    if(n!=-1){                                    //マクロ名なら
      if(deftable[n].narg!=0 || deftable[n].noargflag){//引数を持つなら
        subarg=getArg();                          //引数を取得
      }
      else                                        //引数を持たないなら
        subarg=null;                              //nullにする
      free(word);
      word=replacedef(deftable[n].name,subarg);   //マクロを展開
      if(word==null)                              //wordがnullなら
        do_error("マクロの引数数が合わない");         //引数の数が合わないエラー
      if(deftable[n].narg!=0 || deftable[n].noargflag){//引数を持つなら
        int t=0;
        for(t=0;subarg[t]!=null;t=t+1)
          free(subarg[t]);
        free(subarg);                             //メモリ解放
      }
    }
    arg=strCat(arg,word);                         //引数文字列に単語を追加
    lexical();                                    //単語取得
  }
  return arg;                                     //引数を返す
}



//マクロの展開時の引数の取り出し
//返り値は引数
char[][] getArg(){
  char[][] args;                                  //引数を持つ２次元配列
  int narg=0;                                     //引数数の初期化
  argspace=true;                                  //引数の解析をするフラグ

  args=malloc(sizeof(char[])*ARGSIZE);            //引数配列の初期化

  lexical();                                      //単語取得
  if(strCmp(word,"(")==0){                        //単語が'('なら
    args[narg]=lexarg();                          //１つ引数を取得
    narg=narg+1;                                  //引数数を加算
    while(strCmp(word,",")==0){                   //現在単語が','である間
      args[narg]=lexarg();                        //引数を取得
      narg=narg+1;                                //引数数を加算
      if(narg==5)
        do_error("マクロの引数の最大は4つまで");
    }
    if(strCmp(word,")")!=0)                       //単語が')'でないなら
      do_error("マクロの引数の記述が正しくない");      //引数が正しく終わっていないエラー
  }
  if(strCmp(args[0],"\0")==0){                    //()があるが引数が空
    if(narg!=1)                                   //引数数が1でない
      do_error("引数の数が合わない");                //エラー出力
    narg=0;                                       //引数数を0
  }
  args[narg]=null;                                //引数配列の終わりをnullにする
  argspace=false;                                 //argspaceをオフ
  return args;                                    //引数配列を返す
}



//前後のスペースを削除
char[] deletespace(char[] s){
  int i=0;
  int j=0;
  int bn=0;
  char[] ret=malloc(sizeof(char)*strLen(s)+1);
  for(i=0;s[i]==' ';i=i+1){
  }
  for(j=i;s[j]!=' ' && s[j]!='\0';j=j+1){
    ret[bn]=s[j];
    bn=bn+1;
  }
  ret[bn]='\0';
  free(s);
  return ret;
}



//マクロの登録時の引数を取得する
//スペースは削除
char[][] getArgforM(){
  char[][] args;
  int narg=0;
  naflag=false;                                   //引数空フラグをオフ
  args=malloc(sizeof(char[])*ARGSIZE);            //引数配列の初期化

  lexical();                                      //単語取得
  if(strCmp(word,"(")==0){                        //単語が'('なら
    args[narg]=deletespace(lexarg());             //１つ引数を取得
    narg=narg+1;                                  //引数数を加算
    while(strCmp(word,",")==0){                   //現在単語が','である間
      args[narg]=deletespace(lexarg());           //引数を取得
      narg=narg+1;                                //引数数を加算
      if(narg==5)
        do_error("マクロの引数の最大は4つまで");
    }
    if(strCmp(word,")")!=0)                       //単語が')'でないなら
      do_error("マクロの引数の記述が正しくない");      //引数が正しく終わっていないエラー
    if(strCmp(args[0],"\0")==0){                  //()があるが引数が空
      if(narg!=1)                                 //引数数が1でない
        do_error("引数が書かれていない");            //エラー出力
      narg=0;                                     //引数数を0
      naflag=true;                                //引数が空フラグをオン
    }
  }
  args[narg]=null;                                //引数配列の終わりをnullにする
  return args;                                    //引数配列を返す
}



//定義本体の取得
//定義本体の引数の位置やマクロ名の入子を処理する
//返り値は定義本体
char[] getDef(char[] mname,char[][] arg){
  char[] buffer=malloc(sizeof(char)*INPUTSIZE);   //bufferの初期化
  int wordn=0;                                    //単語の出現番号、引数の出現時に使う
  char[][] subarg;                                //定義本体中のマクロの引数

  skipspace();                                    //スペースをスキップ

  buffer=strCpy(buffer,"\0");                     //初期化
  while(word[0]!='\n'){                           //改行までループ
    int i=0;
    for(i=0;arg[i]!=null;i=i+1){                  //引数と同じかどうかのループ
      if(strCmp(arg[i],word)==0){                 //引数と同じなら
        if(makelist(mname,i,wordn)==-1)           //リストに登録
          do_error("マクロの引数リストに登録できない");//リストの登録不可のエラー
        break;                                    //ループから抜ける
      }
    }

    if(arg[i]==null){                             //引数でないなら
      int n=searchdef(word);                      //マクロ名を探索
      if(n!=-1){                                  //マクロ名なら
        if(deftable[n].narg==0 && !deftable[n].noargflag){//マクロ名の引数数が0なら
          subarg=malloc(sizeof(char[])*1);        //マクロの引数を初期化
          subarg[0]=null;                         //引数にnullを代入
        }
        else{                                     //引数数が0でない
          subarg=getArg();                        //引数を取得
        }
        free(word);
        word=replacedef(deftable[n].name,subarg); //マクロを展開
        int t=0;
        for(t=0;subarg[t]!=null;t=t+1)
          free(subarg[t]);
        free(subarg);                             //メモリの解放
      }
    }
    buffer=strCat(buffer,word);                   //bufferに追加
    lexical();                                    //単語取得
    wordn=wordn+1;                                //単語の出現番号を加算
  }
  if(strCmp(buffer,"\0")==0){                     //bufferが空なら
    free(buffer);
    return null;                                  //nullを返す
  }
  buffer=strCat(buffer,"\0");                     //bufferに'\0'を代入
  return buffer;                                  //bufferを返す
}



char[] macroname;                                 //マクロ名
//マクロ名を登録する前の前処理
//返り値はマクロの引数の多次元配列
char[][] do_makeMname(){
  int type=0;                                     //文字タイプ
  char[][] args;                                  //引数用２次元配列

  if(eofflag)                                     //eofflagがオンなら
    do_error("マクロの定義が正しく終了していない");    //マクロの定義が正常に終わっていないエラー

  type=skipspace();                               //スペースをスキップ
  macroname=malloc(sizeof(char)*strLen(word)+1);
  macroname=strCpy(macroname,word);               //マクロ名を保持

  if(type==T_OTHER){                              //文字タイプがただの文字なら
    if(isAlpha(word[0]) || word[0]=='_'){         //マクロ名の最初の文字がアルファベットなら
      args=getArgforM();                          //引数を取得
      int i=0;
      for(i=0;args[i]!=null;i=i+1){               //引数の数だけループ
        if(!isAlpha(args[i][0]))                  //引数の最初の文字がアルファベットまたは空でないなら
          do_error("マクロの引数の名前はアルファベットから");//引数名不可エラー
      }
      if(makemacro(macroname,i,naflag)==-1){      //マクロ名の登録
        return null;                              //マクロがすでに定義されていたらnullを返す
      }
    }
    else{                                         //マクロ名の最初がアルファベットでないなら
      do_error("マクロ名はアルファベットから");        //アルファベットから始まらないマクロ名不可エラー
    }
  }
  else{                                           //マクロ名が特殊な単語なら
    do_error("マクロ名として適していない");           //特殊なマクロ名不可エラー
  }
  return args;                                    //マクロの引数を返す
}



//#defineを見つけた
int do_define(){
  char[][] args;                                  //引数用２次元配列
  args=do_makeMname();                            //do_makeMname()呼び出し
  char[] def;                                     //定義本体用バッファ

  if(args==null){                                 //argsがnullなら
    args=malloc(sizeof(char[])*1);                //１つだけ要素を持たせる
    args[0]=null;                                 //先頭をnull
    if(strCmp(word,"\n")!=0){                     //マクロ名のすぐ後が改行でないなら
      def=getDef(macroname,args);                 //定義本体取得
    }
    else                                          //マクロ名のすぐ後が改行なら
      def=null;                                   //定義本体をnull

    if(def==null){                                //定義本体がないなら
      def=malloc(sizeof(char)*INPUTSIZE);         //定義本体用バッファ初期化
      def[0]=' ';                                 //" "代入
      def[1]='\0';                                //"\0"代入
    }
    int n=searchdef(macroname);                   //マクロ名を探索
    if(strCmp(def,deftable[n].mdefinition)!=0){   //定義本体が同じでないなら
      linenum=linenum-1;
      do_error("マクロ名が２重定義されている");        //２重定義エラー
    }
    free(args);
    free(def);
    return 0;                                     //正常終了
  }
  if(strCmp(word,"\n")!=0)                        //マクロ名のすぐ後が改行でないなら
    def=getDef(macroname,args);                   //定義本体取得
  else                                            //マクロ名のすぐ後が改行なら
    def=null;                                     //定義本体をnull
  if(def==null){                                  //定義本体がないなら
    if(makedef(macroname," \0")==-1){             //定義本体の登録
      linenum=linenum-1;                          //定義本体があった行に戻る
      do_error("定義本体登録不可");                  //定義本体の登録不可エラー
    }
    int t=0;
    for(t=0;args[t]!=null;t=t+1)
      free(args[t]);
    free(args);
    return 0;                                     //正常終了
  }
  if(makedef(macroname,def)==-1){                 //定義本体の登録
    linenum=linenum-1;                            //定義本体があった行に戻る
    do_error("定義本体登録不可");                    //定義本体の登録不可エラー
  }
  int t=0;
  for(t=0;args[t]!=null;t=t+1)
    free(args[t]);
  free(args);
  free(def);
  return 0;                                       //正常終了
}



//#Edefineを見つけた
int do_Edefine(){
  char[][] args;                                  //引数用２次元配列
  args=do_makeMname();                            //so_makeMname()呼び出し
  char[] def=malloc(sizeof(char)*INPUTSIZE);      //定義本体用バッファ初期化
  if(args==null){                                 //argsがnullなら
    args=malloc(sizeof(char[])*1);                //１つだけ要素を持たせる
    args[0]=null;                                 //先頭をnull
    def=getDef(macroname,args);                   //定義本体取得
    int n=searchdef(macroname);                   //マクロ名を探索
    if(strCmp(def,deftable[n].mdefinition)!=0){   //定義本体が同じなら
      linenum=linenum-1;
      do_error("マクロ名が２重定義されている");        //２重定義エラー
    }
    free(args);
    free(def);
    return 0;                                     //正常終了
  }
  if(strCmp(word,"\n")!=0)                        //マクロ名のすぐ後が改行でないなら
    def=getDef(macroname,args);                   //定義本体取得
  else                                            //マクロ名のすぐ後が改行なら
    def=null;                                     //定義本体をnull
  if(def==null){                                  //定義本体がないなら
    linenum=linenum-1;                            //定義本体があった行に戻る
    do_error("定義本体が存在しない");                //定義本体が存在しない
  }
  int i=0;
  int cnt=1;                                      //()の数
  if(def[0]=='('){                                //定義本体の先頭が'('なら
    for(i=1;def[i]!='\0';i=i+1){                  //定義本体の終わりまでループ
      if(def[i]=='(')                             //'('があったら
        cnt=cnt+1;                                //カウントを加算
      else if(def[i]==')')                        //')'があったら
        cnt=cnt-1;                                //カウントを減算
      if(cnt==0)                                  //カウントが0なら
        break;                                    //ループを抜ける
    }
    if(def[i+1]!='\0'){                           //定義本体の最後までいっていないなら
      linenum=linenum-1;                          //定義本体があった行に戻る
      do_error("()の数があっていない");              //()の数エラー
    }
  }
  else{                                           //定義本体の先頭が'('でないなら
    linenum=linenum-1;                            //定義本体があった行に戻る
    do_error("#Edefineの定義本体には(...)が必要");   //Edefineの仕様に反するエラー
  }
  if(makedef(macroname,def)==-1){                 //定義本体の登録
    linenum=linenum-1;                            //定義本体があった行に戻る
    do_error("定義本体登録不可");                    //定義本体の登録不可エラー
  }
  int t=0;
  for(t=0;args[t]!=null;t=t+1)
    free(args[t]);
  free(args);
  free(def);
  return 0;                                       //正常終了
}



//#Sdefineを見つけた
int do_Sdefine(){
  char[][] args;                                  //引数用二次元配列
  args=do_makeMname();                            //do_makeMname()を呼び出す
  char[] def=malloc(sizeof(char)*INPUTSIZE);      //定義本体用バッファ
  if(args==null){                                 //argsがnullなら
    args=malloc(sizeof(char[])*1);                //１つだけ要素を持たせる
    args[0]=null;                                 //先頭をnull
    def=getDef(macroname,args);                   //定義本体取得
    int n=searchdef(macroname);                   //マクロ名を探索
    if(strCmp(def,deftable[n].mdefinition)!=0){   //定義本体が同じなら
      linenum=linenum-1;
      do_error("マクロ名が２重定義されている");        //２重定義エラー
    }
    free(args);
    free(def);
    return 0;                                     //正常終了
  }
  if(strCmp(word,"\n")!=0)                        //マクロ名のすぐ後が改行でないなら
    def=getDef(macroname,args);                   //定義本体取得
  else                                            //マクロ名のすぐ後が改行なら
    def=null;                                     //定義本体をnull
  if(def==null){                                  //定義本体がないなら
    linenum=linenum-1;                            //定義本体があった行に戻る
    do_error("定義本体が存在しない");                //定義本体がないエラー
  }
  if(def[0]=='(' && def[strLen(def)-1]==')')      //定義本体が()で閉じられているなら
    do_error("#Sdefineの定義本体は()で閉じてはいけない");//#Sdefineの記述エラー
  if(makedef(macroname,def)==-1){                 //定義本体の登録
    linenum=linenum-1;                            //定義本体があった行に戻る
    do_error("定義本体登録不可");                    //定義本体登録不可エラー
  }
  int t=0;
  for(t=0;args[t]!=null;t=t+1)
    free(args[t]);
  free(args);
  free(def);
  return 0;                                       //正常終了
}



//# 行番号　ファイル名を出力
void lineoutput(){
  fprintf(op,"# %d \"%s\"\n",linenum,incdepth[isp].name); //行数とファイル名印字
}



//#includeを見つけた
int do_include(){
  int type;                                               //単語タイプ
  int psp=0;                                              //path配列のスタックポインタ
  char[] includename=malloc(sizeof(char)*INCLUDENAME);    //includeのファイル名
  char[] pathname=malloc(sizeof(char)*INCLUDENAME*2);     //path付きファイル名用
  includename=strCpy(includename,"\0");                   //クリア

  type=skipspace();                                       //スペースをスキップ
  if(type==T_MOJI){                                       //"..."なら
    int i=0;
    if(word[i]=='\'')                                     //'x'なら
      do_error("\"...\"でない");                           //"..."ではない記述エラー
    for(i=1;word[i]!='\"';i=i+1)                          //"..."の...の間
      includename[i-1]=word[i];                           //ファイル名として保存
    includename[i-1]='\0';                                //'\0'追加
  }
  else if(word[0]=='<'){                                  //<...>なら
    lexical();                                            //単語取得
    while(word[0]!='>'){                                  //'>'までループ
      includename=strCat(includename,word);               //ファイル名として追加
      lexical();                                          //単語取得
    }
  }
  else{                                                   //"..."でも<...>でもないなら
    do_error("#includeは<...>または\"...\"");              //includeの記述に反するエラー
  }

  skipspace();                                            //空白を飛ばす
  if(strCmp(word,"\n")!=0){                               //改行でないなら
    lexical();                                            //１単語取得
    printf("worning:%s:line %d:余計な単語がある",incdepth[isp].name,linenum);//#includeの記述に反するwarning
    while(strCmp(word,"\n")!=0)                           //改行でない間
      lexical();                                          //１単語取得
  }

  saveincdepth(linenum,byteh,bytel-1);                    //今のファイル名の読み込みバイト数と行数を保存
  isp=makeincdepth(includename);                          //includeのファイル名を登録
  pathname=strCpy(pathname,includename);                  //pathnameにincludenameを代入
  fd=fopen(incdepth[isp].name,"r");                       //includeのファイル名でオープン
  while(fd==null){                                        //ファイルが存在しない間
    if(psp>=ipsp)                                         //path数を超えたら
      break;                                              //ループを抜ける
    deleteincdepth(pathname);                             //incdepthを削除
    fclose(fd);                                           //ファイルをクローズ
    pathname=strCpy(pathname,incpath[psp]);               //pathを追加
    pathname=strCat(pathname,includename);                //ファイル名を追加
    isp=makeincdepth(pathname);                           //includeのファイル名を登録
    fd=fopen(incdepth[isp].name,"r");                     //includeのファイル名でオープン
    psp=psp+1;                                            //pspを加算
  }
  free(includename);
  free(pathname);
  if(fd==null){                                           //ファイルが存在しない
    isp=isp-1;                                            //今のファイルにスタックポインタ移動
    linenum=linenum-1;                                    //行数を戻す
    do_error("includeのファイルが存在しない");                //ファイルがないエラー
  }
  byteh=0;                                                //bytehの初期化
  bytel=0;                                                //bytelの初期化
  linenum=1;                                              //linenumの初期化
  nexthch='\0';                                           //次の文字を初期化
  nextlch='\0';                                           //次の文字を初期化
  nextwch='\0';                                           //次の文字を初期化
  eofflag=false;                                          //eofflagを念のためオフ
  lineoutput();                                           //ファイルの始まりを印字
  return 0;                                               //正常終了
}



//#ifdefを見つけた
int do_ifdef(int con){
  if(con==1)                                //条件が成立するなら
    sp=makeif(true);                        //成立を表す
  else                                      //条件が不成立なら
    sp=makeif(false);                       //不成立を表す
  return 0;                                 //正常終了
}



//#ifndefを見つけた
int do_ifndef(int con){
  if(con==0)                                //条件が成立するなら
    sp=makeif(true);                        //成立を表す
  else                                      //条件が不成立なら
    sp=makeif(false);                       //不成立を表す
  return 0;                                 //正常終了
}



//#elseを見つけた
int do_else(){
  sp=makeelse();                            //#elseの処理
  if(sp==-1)                                //spが-1なら
    do_error("#elseが#if~の後にない");        //エラー処理
  return 0;                                 //正常終了
}



//#elseifdefを見つけた
int do_elseifdef(int con){
  if(con==1)                                                 //条件が成立するなら
    sp=makeelseif(true);                                     //成立を表す
  else                                                       //条件が不成立なら
    sp=makeelseif(false);                                    //不成立を表す
  if(sp==-1)                                                 //spが-1なら
    do_error("#elseif~が#if~の後にないか#elseの後ろにある");     //エラー処理
  return 0;                                                  //正常終了
}



//＃elseifndefを見つけた
int do_elseifndef(int con){
  if(con==0)                                                 //条件が成立するなら
    sp=makeelseif(true);                                     //成立を表す
  else                                                       //条件が不成立なら
    sp=makeelseif(false);                                    //不成立を表す
  if(sp==-1)                                                 //spが-1なら
    do_error("#elseif~が#if~の後にないか#elseの後ろにある");     //エラー処理
  return 0;                                                  //正常終了
}



//#endifを見つけた
int do_endif(){
  sp=deleteifel();                            //#ifの深さを減らす
  if(sp<0)                                    //spが負の値なら
    do_error("#ifと#endifの数が合わない");       //#ifと#endifの数が合わないエラー
  return 0;                                   //正常終了
}



//#ifなどの条件チェック
int conditioncheck(){
  skipspace();                                //スペースをスキップ
  int n=searchdef(word);                      //マクロ名探索
  if(n>-1)                                    //マクロ名が見つかったなら
    return 1;                                 //1を返す
  return 0;                                   //マクロ名なしなら0を返す
}



//#undefを見つけた
int do_undef(){
  skipspace();                                //スペースをスキップ
  if(deletedef(word)==-1)                     //マクロ名を消去
    do_error("undef不可");                    //消去不可のエラー
  lexical();
  if(strCmp(word,"\n")!=0)
    do_error("#undefの記述が間違っている");
  return 0;                                   //正常終了
}



//単語の'.'より前の部分のみを取り出す
char[] dotdelete(char[] str){
  int bufn=0;                                 //単語の位置
  int rbufn=0;                                //返り値用バッファの位置
  char[] ret=malloc(sizeof(char)*strLen(str)+1);//バッファの初期化
  for(bufn=0;str[bufn]!='.';bufn=bufn+1){     //'.'までループ
    ret[rbufn]=str[bufn];                     //返り値用バッファに代入
    rbufn=rbufn+1;                            //文字位置を加算
  }
  ret[rbufn]='\0';                            //'\0'を代入
  return ret;                                 //バッファを返す
}



//bufferの出力
void output(){
  int i=0;
  for(i=0;ipbuf[i]!='\0';i=i+1)       //bufferの終わりまでループ
    fputc(ipbuf[i],op);               //bufferを印字
}



boolean eflag=false;                                                         //-E用のフラグ
//-D -E -Iオプションの解析
int option(int optionn,char[][] optionarg){
  int i=0;
  int j=0;
  char[] dm;                                                                 //-Dオプションのマクロ名用
  char[] dd;                                                                 //-Dオプションの定義本体用
  char[] ii;                                                                 //-Iオプションのinclude path
  for(i=1;i<optionn;i=i+1){                                                  //引数の数だけループ
    for(j=0;optionarg[i][j]!='\0';j=j+1){                                    //引数の解析
      if(optionarg[i][j]=='-'){                                              //１文字目が'-'なら
        j=j+1;                                                               //次の文字
        if(optionarg[i][j]=='D'){                                            //２文字目が'D'なら
          j=j+1;                                                             //次の文字
          dm=malloc(sizeof(char)*10);                                        //dmを初期化
          int k=0;
          for(k=0;optionarg[i][j]!='=' && optionarg[i][j]!='\0';k=k+1){      //'='または'\0'までループ
            dm[k]=optionarg[i][j];                                           //マクロ名を取得
            j=j+1;                                                           //次の文字
          }
          dm[k]='\0';                                                        //文字の終わり
          makemacro(dm,0,false);                                             //マクロ名の登録
          if(optionarg[i][j]=='\0'){                                         //'\0'なら
            makedef(dm," \0");                                               //定義本体の登録
            free(dm);
            break;                                                           //次の引数へ
          }
          j=j+1;                                                             //次の文字
          dd=malloc(sizeof(char)*10);                                        //ddを初期化
          for(k=0;optionarg[i][j]!='\0';k=k+1){                              //終わりまでループ
            dd[k]=optionarg[i][j];                                           //定義本体を取得
            j=j+1;                                                           //次の文字
          }
          dd[k]='\0';                                                        //文字の終わり
          makedef(dm,dd);                                                    //定義本体を登録
          free(dm);
          free(dd);
          break;
        }
        else if(optionarg[i][j]=='E'){                                       //２文字目が'E'なら
          if(optionarg[i][j+1]!='\0')                                        //次の文字が終わりじゃないなら
            break;                                                           //次の引数へ
          eflag=true;                                                        //eflagをオン
          op=stdout;                                                         //opを標準出力に
          break;
        }
        else if(optionarg[i][j]=='I'){                                       //２文字目が'I'なら
          j=j+1;                                                             //次の文字
          ii=malloc(sizeof(char)*INCLUDENAME);                               //iiを初期化
          int k=0;
          for(k=0;optionarg[i][j]!='\0';k=k+1){                              //'\0'までループ
            ii[k]=optionarg[i][j];                                           //マクロ名を取得
            j=j+1;                                                           //次の文字
          }
          ii[k]='/';                                                         //ファイルの区切り
          ii[k+1]='\0';                                                      //文字の終わり
          incpath[ipsp]=ii;                                                  //pathを代入
          ipsp=ipsp+1;                                                       //ipspを加算
          break;
        }
        else                                                                 //'D' 'E'以外なら
          break;                                                             //次の引数
      }
      else                                                                   //１文字目が'-'でないなら
        return i;                                                            //引数位置を返す
    }
  }
  return -1;                                                                 //-1を返す
}


public int main(int argc,char[][] argv){
  char[] bufer;                               //マクロ展開時用バッファ
  char[] opname;                              //出力ファイル名
  int linen=1;                                //行番号
  char buf;                                   //現在文字
  int bufn;                                   //現在文字位置
  int type;                                   //字句解析タイプ
  int condition;                              //条件のコンディション

  incpath=malloc(sizeof(char[])*PATHNUM);     //path配列の初期化
  int oo=option(argc,argv);                   //option()を呼び出す
  if(oo==-1)                                  //ooが-1なら
    do_error("引数にファイルがない");            //エラー出力
  isp=makeincdepth(argv[oo]);                 //ソースファイルをテーブルに追加
  fd=fopen(incdepth[isp].name,"r");           //入力ファイルオープン
  if(!eflag){                                 //elseflagがオフなら
    opname=dotdelete(argv[oo]);               //出力ファイル名の'.'以前を取得
    opname=strCat(opname,".i\0");             //出力ファイル名作成
    op=fopen(opname,"w");                     //出力ファイルオープン
  }
  lineoutput();                               //ファイルの始まり

  char[][] subarg;                            //引数用２次元配列
  sp=makeif(true);                            //0番目は常にtrue
  word=malloc(sizeof(char)*INPUTSIZE);        //単語の1番最初の初期化

  while(!eofflag){                            //入力ファイルから単語を読み込み
    type=lexical();                           //入力の単語のタイプ
    if(word[0]=='#'){                         //'#'を見つけたなら
      lexflag=true;                           //lexflagをオン
      continue;                               //ループの最初に戻る
    }
    if(iftable[sp].condition){                //#if #elseの条件が成立している
      if(type==T_MOJI || type==T_OTHER){      //"..."または'x'またはただの単語なら
        if(lexflag){                          //'#'を見つけていたら
          fputc('#',op);                      //'#'を印字
          output();                           //文字印字
          lexflag=false;                      //lexflagをオフ
          continue;                           //ループの最初に戻る
        }
        int n=searchdef(word);                //マクロ名を探索
        if(n!=-1){                            //マクロ名なら
          if(deftable[n].narg!=0 || deftable[n].noargflag){//引数を持つまたは引数が空なら
            subarg=getArg();                  //引数を取得
          }
          else                                //引数を持たないなら
            subarg=null;                      //nullにする
          free(word);
          word=replacedef(deftable[n].name,subarg);//bufferにマクロを展開
          if(word==null)                     //ipbufがnullなら
            do_error("マクロの引数数が合わない"); //引数の数が合わないエラー
          ipbuf=strCpy(ipbuf,word);
          if(deftable[n].narg!=0 || deftable[n].noargflag){//引数があるなら
            int t=0;
            for(t=0;subarg[t]!=null;t=t+1)
              free(subarg[t]);
            free(subarg);                     //メモリ解放
          }
        }
        output();                             //文字印字
      }
      else if(type==T_DEFINE){                //#defineなら
        lexflag=false;                        //lexflagをオフ
        do_define();                          //do_define()を呼び出し
        output();                             //文字印字
      }
      else if(type==T_EDEFINE){               //#Edefineなら
        lexflag=false;                        //lexflagをオフ
        do_Edefine();                         //do_Edefine()呼び出し
        output();                             //文字印字
      }
      else if(type==T_SDEFINE){               //#Sdefineなら
        lexflag=false;                        //lexflagをオフ
        do_Sdefine();                         //do_Sdefine()呼び出し
        output();                             //文字印字
      }
      else if(type==T_INCLUDE){               //#includeなら
        lexflag=false;                        //lexflagをオフ
        do_include();                         //do_include()呼び出し
      }
      else if(type==T_UNDEF){                 //#undefなら
        lexflag=false;                        //lexflagをオフ
        do_undef();                           //do_undef()呼び出し
        output();                             //文字印字
      }
    }
    else{                                     //#if #elseの条件が不成立なら
      lexflag=false;                          //lexflagをオフ
      if(strCmp(word,"\n")==0)                //今の単語が'\n'なら
        output();                             //文字印字
    }
    if(type==T_ELSE){                         //#elseなら
      lexflag=false;                          //lexflagをオフ
      do_else();                              //do_else()呼び出し
    }
    else if(type==T_IFDEF){                   //#ifdefなら
      lexflag=false;                          //lexflagをオフ
      condition=conditioncheck();             //条件をチェック
      do_ifdef(condition);                    //do_ifdef()呼び出し
    }
    else if(type==T_IFNDEF){                  //#ifndefなら
      lexflag=false;                          //lexflagをオフ
      condition=conditioncheck();             //条件をチェック
      do_ifndef(condition);                   //do_ifndef()呼び出し
    }
    else if(type==T_ELSEIFDEF){               //#elseifdefなら
      lexflag=false;                          //lexflagをオフ
      condition=conditioncheck();             //条件をチェック
      do_elseifdef(condition);                //do_elseifdef()呼び出し
    }
    else if(type==T_ELSEIFNDEF){              //#elseifndefなら
      lexflag=false;                          //lexflagをオフ
      condition=conditioncheck();             //条件をチェック
      do_elseifndef(condition);               //do_elseifndef()呼び出し
    }
    else if(type==T_ENDIF){                   //#endifなら
      lexflag=false;                          //lexflagをオフ
      do_endif();                             //do_endif()呼び出し
    }

    if(eofflag && isp!=0){                   //今見ているファイルがeofでincludeテーブルのスタックポインタが１番下でないなら
      fclose(fd);                             //今見ているファイルをクローズ
      isp=deleteincdepth(incdepth[isp].name); //includeテーブルを１つ削除
      fd=fopen(incdepth[isp].name,"r");       //前のファイルをオープン
      fseek(fd,incdepth[isp].dbyteh,incdepth[isp].dbytel);  //元の位置に移動
      byteh=incdepth[isp].dbyteh;             //dbytehを取得
      bytel=incdepth[isp].dbytel;             //dbytelを取得
      linenum=incdepth[isp].linen;            //linenumを取得
      nexthch='\0';                           //次の文字を初期化
      nextlch='\0';                           //次の文字を初期化
      nextwch='\0';                           //次の文字を初期化
      fputc('\n',op);                         //改行を印字
      lineoutput();                           //ファイルの始まり
      eofflag=false;                          //eofflagを戻す
    }
  }
  if(sp!=0)                                   //#if #elseの数が0でない
    do_error("#endifの数が合わない");           //#endifの数が合わない
  fclose(fd);                                 //入力ファイルをクローズ
  fclose(op);
  return 0;
}

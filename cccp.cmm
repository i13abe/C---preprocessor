#include <stdio.hmm>
#include <stdlib.hmm>
#include <string.hmm>
#include <ctype.hmm>
#include "./type.hmm"
#include "./difinition.hmm"
#include "./including.hmm"

#define INPUTSIZE 50      //単語のマックスサイズ
#define ARGSIZE 5         //マクロの引数数。内一つはnull用
#define TABLESIZE 20
#define INDEPTHSIZE 10
#define INCLUDENAME 20
#define IFDEPTH 10        //ifの入れ子の深さ


unsigned char[] is_idchar;                  // 0~9 a~z A~Z
unsigned char[] is _idstart;                // a~z A~Z
unsigned char[] is_hor_space;               // ' ' \t \v \f \r
unsigned char[] is_space;                   // ' ' \t \v \f \n \r
public definition[] deftable=array(TABLESIZE);  //deftableの初期化
public filelist[] incdepth=array(INDEPTHSIZE); //includeのdepthの初期化
FILE fd;                                    //入力ファイル
FILE op;                                    //出力ファイル
unsigned char[] ipbuf=array(INPUTSIZE);     //入力ファイル用バッファ
char[] word;                                //単語用バッファ
boolean eofflag=false;                      //EOF用フラグ
int[] ifdepth=array(IFDEPTH);               //ifの入れ子用スタック
int sp=0;                                   //ifdepth用スタックポインタ
int linenum=1;                              //行番号
int byte=0;                                 //byte数



//is_idchar is_idstart is_hor_space is_spaceの初期化
void initialize_char_syntax(){
  int i;
  is_idchar=malloc(256);
  is_idstart=malloc(256);
  is_hor_space=malloc(256);
  is_space=malloc(256);


  //a~z A~Zの初期化
  for(i='a';i<='z';i++){
    is_idchar[i]=1;
    is_idstart[i]=1;
    is_idchar[i-'a'+'A']=1;
    is_idstart[i-'a'+'A']=1;
  }

  //0~9の初期化
  for(i=0;i<=9;i++){
    is_idchar[i]=1;
  }

  //is_hor_spaceの初期化
  is_hor_space[' ']=1;
  is_hor_space[\t]=1;
  is_hor_space[\v]=1;
  is_hor_space[\f]=1;
  is_hor_space[\r]=1;

  //is_spaceの初期化
  is_space[' ']=1;
  is_space[\t]=1;
  is_space[\v]=1;
  is_space[\v]=1;
  is_space[\f]=1;
  is_space[\n]=1;
  is_space[\r]=1;
}



int enterlcnt=0;         //改行の数
char nextlch='\0';      //getL()用の次文字
// \\nを無視する１文字入力
char getL(){
  char lch;
  if(nextlch!='\0' && nextlch!='\\'){
    lch=nextlch;
    nextlch='\0';
    return lch;
  }
  if(nextlch=='\\')
    lch='\\';
  else
    lch=fgetc(fd);
  while(lch=='\\'){
    if(!feof(fd))
      nextlch=fgetc(fd);
    else{
      eofflag=true;
      return '\n';
    }
    if(nextlch=='\n'){
      if(!feof(fd))
        do{
          lch=fgetc(fd);
          if(feof(fd))
            return '\n';
        }while(lch==' ');
      else{
        eofflag=true;
        return '\n';
      }
      enterlcnt=enterlcnt+1;
      nextlch='\0';
    }
    else
      return '\\';
  }
  return lch;
}



int enterhcnt=0;        //改行の数
char nexthch='\0';      //getH()用の次文字
boolean sentense=false;
// コメントを削除する１文字入力
char getH(){
  char hch;
  int commentflag=0;

  if(nexthch!='\0'){
    hch=nexthch;
    nexthch='\0';
    return hch;
  }

  hch=getL();

  //'x'または"..."の時
  if(hch=='\"'){
    if(!sentense){
      sentense=true;
      return hch;
    }
    else{
      sentense=false;
      return hch;
    }
  }

  if(hch=='\n' && sentense){
    sentense=false;
    return hch;
  }


  if(sentense)
    return hch;


  //最初に'/'を見つけた
  while(hch=='/'){
    nexthch=getL();
    if(eofflag)
      break;

    //次の文字が'/'だった
    if(nexthch=='/'){
      nexthch='\0';
      while(hch!='\n'){
        hch=getL();
        if(eofflag)
          return '\n';
      }
      enterhcnt=enterhcnt+1;
    }

    //次の文字が'*'だった
    else if(nexthch=='*'){
      nexthch='\0';
      commentflag=1;
      while(commentflag==1){
        while(hch!='*'){
          if(hch=='\n')
            enterhcnt=enterhcnt+1;
          hch=getL();
          if(eofflag){

            printf("コメントエラー\n");
            return '\n';
          }
        }
        hch=getL();
        if(eofflag){

          printf("コメントエラー\n");
          return '\n';
        }
        if(hch=='/')
           commentflag=0;
      }
    }

    //次の文字がただの文字だった
    else
      return hch;

    hch=getL();
    if(eofflag)
      return hch;
  }
  return hch;
}



char nextwch='\0';        //次の文字を取得する
boolean wordflag=false;   //今の文字と次の文字がアルファベットならtrue
boolean wordspace=false;  //次の文字が' 'になった時true
boolean wordpunc=false;   //次の文字が','になった時true
boolean linehead=true;    //行の先頭ならtrue
int parentdepth=0;        //'()'の深さ
//今の文字と次の文字を同時にとり、記号と単語を分ける
//返り値は今の文字だが呼び出した関数は主にフラグをみる
char getWord(){
  char wch;     //今の文字

  //次の文字が空でなかったら今の文字に入れる
  if(nextwch!='\0'){
    wch=nextwch;
    nextwch='\0';
  }

  //次の文字が空だったら今の文字を取得
  else{
    wch=getH();
  }

  nextwch=getH();   //次の文字取得


  //次の文字が'('ならインクリメント
  if(nextwch=='('){
    parentdepth=parentdepth+1;
  }

  //次の文字が')'ならデクリメント
  else if(nextwch==')'){
    parentdepth=parentdepth-1;
  }

  //次の文字が','ならフラグをオン
  else if(nextwch==','){
    wordpunc=true;
  }

  //今の文字が 0~9 a~z A~Z '#' '.'のどれかか
  if(isAlnum(wch) || wch=='#' || wch=='.'){
    linehead=false;       //行の先頭フラグをオン
    wordflag=true;        //単語であるのでフラグをオン

    //次の文字が記号なら
    if(!isAlnum(nextwch) && nextwch!='#' && nextwch!='.'){
      wordflag=false;     //フラグをオフ
    }
  }

  //今の文字が','ならフラグをオフ
  else if(wch==','){
    linehead=false;
    wordpunc=false;
  }

  //今の文字が' 'なら
  else if(wch==' '){
    //行の先頭ならそのまま' 'を返す
    if(linehead){
      wordspace=false;
        return wch;
    }

    //フラグがオンなら１つだけ' 'を返して他の' 'は飛ばす
    else if(wordspace){
      wordspace=false;
      while(nextwch==' ')
        nextwch=getH();
      return wch;
    }
  }

  //今の文字が記号ならフラグをオフ
  else{
    linehead=false;
    wordflag=false;
  }

  //次の文字が' 'ならフラグをオン
  if(nextwch==' ')
    wordspace=true;

  return wch;
}



//コメントまたは\\n時の改行の数だけ改行する
//返り値はipbufの位置
int entercount(){
  int i;
  for(i=0;i<(enterhcnt+enterlcnt);i=i+1){
    ipbuf[i]='\n';
  }
  enterlcnt=0;
  enterhcnt=0;
  return i;
}


//字句解析
int lexical(){
  int bufn=0;                   //現在文字位置
  int wordn=0;                   //単語の位置
  char buf;                     //入力文字

  word=malloc(sizeof(char)*INPUTSIZE);


  buf=getWord();

  //スペースか改行か記号まで文字を取り出す
  //ただし'#'と'.'は含めておく
  while(wordflag || sentense){
    ipbuf[bufn]=buf;
    word[wordn]=buf;
    bufn=bufn+1;
    wordn=wordn+1;
    buf=getWord();
  }

  //改行で終わったなら行先頭フラグを立てる
  if(buf=='\n'){
    linenum=linenum+1;
    bufn=entercount();
    linehead=true;
    if(parentdepth!=0)
      return T_ERROR;
  }


  ipbuf[bufn]=buf;
  bufn=bufn+1;
  ipbuf[bufn]='\0';
  word[wordn]=buf;
  wordn=wordn+1;
  word[wordn]='\0';

  int wordlen=strLen(word);

  //字句解析
  if(strCmp(word,"#Edefine")==0){
    return T_EDEFINE;
  }
  else if(strCmp(word,"#Sdefine")==0){
    return T_SDEFINE;
  }
  else if(strCmp(word,"#include")==0){
    return T_INCLUDE;
  }
  else if(strCmp(word,"#else")==0){
    return T_ELSE;
  }
  else if(strCmp(word,"#ifdef")==0){
    return T_IFDEF;
  }
  else if(strCmp(word,"#ifndef")==0){
    return T_IFNDEF;
  }
  else if(strCmp(word,"#elseifdef")==0){
    return T_ELSEIFDEF;
  }
  else if(strCmp(word,"#elseifndef")==0){
    return T_ELSEIFNDEF;
  }
  else if(strCmp(word,"#endif")==0){
    return T_ENDIF;
  }
  else if(strCmp(word,"#undef")==0){
    return T_UNDEF;
  }
  else if(word[0]=='\'' && word[wordlen-1]=='\''){
    return T_MOJI;
  }
  else if(word[0]=='\"' && word[wordlen-1]=='\"'){
    return T_MOJI;
  }
  return T_OTHER;
}


int skipspace(){
  int type;
  lexical();
  while(strCmp(word," ")==0)
    type=lexical();
  return type;
}

//(x,y)とかの引数の取り出し
//返り値は引数
int narg;     //引数数
char[][] getArg(){
  char[][] args;      //引数を持つ配列
  char[] arg;         //引数の文字
  narg=0;             //引数の数
  int endparent;      //引数の終わり位置

  //'('がないなら終わり位置は0
  if(parentdepth==0)
    endparent=0;
  //'('があったら1つ減らして値を持つ
  //'('が複数回呼ばれている時用に1減らす
  else
    endparent=parentdepth-1;

  args=malloc(sizeof(char[])*ARGSIZE);

  while(parentdepth!=endparent){
    arg=malloc(sizeof(char)*ARGSIZE);
    lexical();
    while(word[0]=='(' || word[0]==',' ||word[0]==')')
      lexical();
    arg=strCat(arg,word);
    while(!wordpunc && parentdepth!=endparent){
      lexical();
      arg=strCat(arg,word);
    }
    args[narg]=arg;
    narg=narg+1;
  }

  if(narg!=0)
    lexical();

  args[narg]=null;
  return args;
}



//定義本体の取得
//定義本体の引数の位置やマクロ名の入子を処理する
//返り値は定義本体
char[] getDef(char[] mname,char[][] arg){
  char[] buffer=malloc(sizeof(char)*INPUTSIZE);
  int wordn=0;          //単語の出現番号、引数の出現時に使う
  char[] submacro;      //途中で見つけたマクロ名を保持
  char[][] subarg;      //定義本体中のマクロの引数
  int subnarg=narg;     //引数数を保持

  skipspace();

  while(word[0]!='\n'){

    //引数と同じならリストに登録
    int i=0;
    for(i=0;i<subnarg;i=i+1){
      if(strCmp(arg[i],word)==0){
        if(makelist(mname,i,wordn)==-1)
          return null;
      }
    }

    //引数でないならマクロ名かどうかを比較
    if(i==subnarg){
      int n=searchdef(word);
      if(n!=-1){
        submacro=word;
        if(deftable[n].narg==0){
          subarg=malloc(sizeof(char[])*1);
          subarg[0]=null;
        }
        else{
          subarg=getArg();
        }
        ipbuf=replacedef(submacro,subarg);
      }
    }

    buffer=strCat(buffer,ipbuf);
    lexical();
    wordn=wordn+1;
  }
  buffer=strCat(buffer,"\0");
  return buffer;
}




//マクロ名を登録する前の前処理
//返り値はマクロの引数の多次元配列
char[] macroname;
char[][] do_makeMname(){
  int type=0;   //文字タイプ
  char[][] args;

  //マクロの定義ができずに終了
  if(feof(fd))
    return null;

  type=skipspace();
  macroname=word;


  //文字タイプがただの文字かどうか
  if(type==T_OTHER){
    //マクロ名の最初の文字がアルファベットかどうか
    if(isAlpha(word[0])){
      args=getArg();           //引数の配列
      int i=0;
      for(i=0;i<narg;i=i+1){
        //引数の最初の文字がアルファベットかどうか
        if(!isAlpha(args[i][0]))
          //引数名不可
          return null;
      }

      if(makemacro(macroname,narg)==-1) //マクロ名の登録
        return null;
    }
    else{
      //アルファベットから始まらないマクロ名不可
      return null;
    }
  }
  else{
    //特殊なマクロ名不可
    return null;
  }
  return args;
}


//#Edefineを見つけた
int do_Edefine(){
  char[][] args;               //引数

  args=do_makeMname();
  if(args==null)
    return -1;

  char[] def=malloc(sizeof(char)*INPUTSIZE);  //定義本体用バッファ


  def=getDef(macroname,args);             //定義本体取り出し
  if(def==null)         //定義本体がないなら
    return -1;

  int i=0;
  int cnt=1;
  if(def[0]=='('){
    for(i=1;def[i]!='\0';i=i+1){
      if(def[i]=='(')
        cnt=cnt+1;
      else if(def[i]==')')
        cnt=cnt-1;

      if(cnt==0)
        break;
    }
    if(def[i+1]!='\0')
      return -1;
  }
  else
    return -1;

  if(makedef(macroname,def)==-1)  //定義本体の登録
    return -1;
  return 0;
}


int do_Sdefine(){
  char[][] args;
  args=do_makeMname();
  if(args==null)
    return -1;

  char[] def=malloc(sizeof(char)*INPUTSIZE);  //定義本体用バッファ

  def=getDef(macroname,args);             //定義本体取り出し
  if(def==null)         //定義本体がないなら
    return -1;

  if(makedef(macroname,def)==-1)  //定義本体の登録
    return -1;
  return 0;
}


int do_include(char[] ipbuf,int bufn){

}


int do_ifdef(int con){
  if(ifdepth[sp]==1){
    sp=sp+1;
    if(con==1){
      ifdepth[sp]=1;
    }
    else{
      ifdepth[sp]=0;
    }
  }
  else{
    sp=sp+1;
    ifdepth[sp]=0;
  }
  return 0;
}


int do_ifndef(int con){
  if(ifdepth[sp]==1){
    sp=sp+1;
    if(con==0){
      ifdepth[sp]=1;
    }
    else{
      ifdepth[sp]=0;
    }
  }
  else{
    sp=sp+1;
    ifdepth[sp]=0;
  }
  return 0;
}


int do_else(){
  if(ifdepth[sp-1]==1){
    if(ifdepth[sp]==1){
      ifdepth[sp]=0;
    }
    else{
      ifdepth[sp]=1;
    }
  }
  else{
    ifdepth[sp]=0;
  }
  return 0;
}


int do_elseifdef(int con){
  if(ifdepth[sp-1]==1){
    if(ifdepth[sp]==1){
      ifdepth[sp]=0;
    }
    else{
      if(con==1){
        ifdepth[sp]=1;
        ifdepth[sp-1]=0;
      }
      else{
        ifdepth[sp]=0;
      }
    }
  }
  else{
    ifdepth[sp]=0;
  }
  return 0;
}


int do_elseifndef(int con){
  if(ifdepth[sp-1]==1){
    if(ifdepth[sp]==1){
      ifdepth[sp]=0;
    }
    else{
      if(con==0){
        ifdepth[sp]=1;
        ifdepth[sp-1]=0;
      }
      else{
        ifdepth[sp]=0;
      }
    }
  }
  else{
    ifdepth[sp]=0;
  }
  return 0;
}


int do_endif(){
  ifdepth[sp]=0;
  sp=sp-1;
  return 0;
}


int conditioncheck(){
  skipspace();
  int n=searchdef(word);
  if(n>-1)
    return 1;
  return 0;
}


int do_undef(){
  skipspace();
  if(deletedef(word)==-1)
    return -1;
  return 0;
}


void do_error(){

}


void construction(){

}


public int main(int argc,char[][] argv){

  char[] bufer;         //マクロ展開時用バッファ
  int linen=1;            //行番号
  char buf;             //現在文字
  int bufn;             //現在文字位置
  int type;             //字句解析タイプ
  int condition;

  initialize_char_syntax();
  fd=fopen(argv[1],"r");       //入力ファイル

  char[][] subarg;
  char[] submacro;
  ifdepth[sp]=1;    //ifdepthの最初は常に１

  //入力ファイル読み込み
  while(!feof(fd)){
    type=lexical()            //入力行の単語のタイプ

    //タイプがEdefineなら
    if(type==T_EDEFINE){

      //その行分の改行の出力

      do_Edefine();
    }
    else if(type==T_SDEFINE){
      do_Sdefine();
    }
    else if(type==T_INCLUDE){
      do_include();
    }
    else if(type==T_ELSE){
      do_else();
    }
    else if(type==T_IFDEF){
      do_ifdef();
    }
    else if(type==T_IFNDEF){
      do_ifndef();
    }
    else if(type==T_ELSEIFDEF){
      do_elseifdef();
    }
    else if(type==T_ELSEIFNDEF){
      do_elseifndef();
    }
    else if(type==T_ENDIF){
      do_endif();
    }
    else if(type==T_UNDEF){
      do_undef();
    }
    else if(type==T_MOJI){

      //何も考えずに出力

    }
    else if(type=T_OTHER){

      //マクロ名かどうかの探索またはoutput出力

    }

  }
  fclose(fd);


}

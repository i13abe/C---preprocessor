#include <stdio.hmm>
#include <stdlib.hmm>
#include <string.hmm>
#include <ctype.hmm>
#include "./type.hmm"
#include "./difinition.hmm"
#include "./including.hmm"

#define INPUTSIZE 50                            //単語のマックスサイズ
#define ARGSIZE 5                               //マクロの引数数。内一つはnull用
#define TABLESIZE 20                            //definitionテーブルのサイズ
#define INDEPTHSIZE 10                          //includeの入れ子サイズ
#define INCLUDENAME 20                          //includeのファイル名の大きさ
#define IFDEPTH 10                              //ifの入れ子の深さ



public definition[] deftable=array(TABLESIZE);  //deftableの初期化
public filelist[] incdepth=array(INDEPTHSIZE);  //includeのdepthの初期化
FILE fd;                                        //入力ファイル
FILE op;                                        //出力ファイル
unsigned char[] ipbuf=array(INPUTSIZE);         //入力ファイル用バッファ
char[] word;                                    //単語用バッファ
boolean eofflag=false;                          //EOF用フラグ
int[] ifdepth=array(IFDEPTH);                   //ifの入れ子用スタック
int sp=0;                                       //ifdepth用スタックポインタ
boolean elseflag=false;                         //複数elseの内１つでも条件が成立した時のフラグ
int isp=0;                                      //includeテーブルのスタックポインタ
int linenum=1;                                  //行番号
int bytel=0;                                    //下位16bitのbyte数
int byteh=0;                                    //上位16bitのbyte数



//byteh,bytelの加算、オーバーフローに対応する
void byteplus(){
  if(bytel==32767){                   //bytelがオーバーフロー寸前
    byteh=byteh+sizeof(char);         //bytehを加算
    bytel=0;                          //bytelを初期化
  }
  else{                               //bytelがまだ加算可能
    bytel=bytel+sizeof(char);         //bytelを加算
  }
}



int enterlcnt=0;                      //\\nの改行の数
char nextlch='\0';                    //getL()用の次文字

// \\nを無視する１文字入力
char getL(){
  char lch;                           //今の文字

  if(nextlch!='\0' && nextlch!='\\'){ //次の文字が空ではなく'\\'でないなら（次の文字が何か持っている）
    lch=nextlch;                      //今の文字は次の文字をみる
    nextlch='\0';                     //次の文字を空にする
    byteplus();                       //見た文字の数だけbyteを加算
    return lch;                       //今の文字を返す
  }

  else if(nextlch=='\\'){             //次の文字が'\\'なら
    lch=nextlch;                      //今の文字は次の文字を見る
    nextlch='\0';                     //次の文字を空にする
    byte=byte+sizeof(char);           //見た文字の数だけbyteを加算
  }

  else{                               //次の文字が空なら
    if(!feof(fd)){                    //eofでないなら
      lch=fgetc(fd);                  //今の文字を入力
      byteplus();                     //見た文字の数だけbyteを加算
    }
    else{                             //eofなら
      eofflag=true;                   //eofflagをオン
      return '\n';                    //eof時は改行を返す
    }
  }

  while(lch=='\\'){                   //今の文字が'\\'なら
    if(!feof(fd)){                    //eofでないなら
      nextlch=fgetc(fd);              //次の文字を入力
    }
    else{                             //eofなら
      eofflag=true;                   //eofflagをオン
      return '\n';                    //eof時は改行を返す
    }

    if(nextlch=='\n'){                //次の文字が改行なら
      linenum=linenum+1;              //行数をインクリメント
      if(!feof(fd)){                  //eofでないなら
        do{                           //結合時に' 'は削除して結合するため、以降' 'である間は続く
          lch=fgetc(fd);              //次の文字のさらに次を見る
          byteplus();                 //見た文字の数だけbyteを加算
          if(feof(fd)){               //eofなら
            eofflag=true;             //eofflagをオン
            return '\n';              //eof時は改行を返す
          }
        }while(lch==' ');             //' 'ならループ
      }
      else{                           //eofなら
        eofflag=true;                 //eofflagをオン
        return '\n';                  //eof時は改行を返す
      }
      enterlcnt=enterlcnt+1;          //改行の数だけcntを増やす
      nextlch='\0';                   //次の文字を空にする
    }
    else                              //次の文字が改行でないなら
      return lch;                     //今の文字を返す
  }

  if(lch=='\n')                       //今の文字が改行なら
    linenum=linenum+1;                //改行回数を加算

  return lch;                         //今の文字を返す
}



int enterhcnt=0;                      // /*~*/の中の改行の数
char nexthch='\0';                    //getH()用の次文字
boolean sentense=false;               //"..."または'x'用のフラグ

// コメントを削除する１文字入力
char getH(){
  char hch;                           //今の文字
  boolean commentflag=false;          //コメントである時のフラグ

  if(nexthch!='\0'){                  //次の文字が空でないなら
    hch=nexthch;                      //今の文字に次の文字を代入
    nexthch='\0';                     //次の文字を空に
    return hch;                       //今の文字を返す
  }

  hch=getL();                         //今の文字取得

  if(hch=='\"'){                      //今の文字が'\"'なら
    if(!sentense)                     //sentenseがオンでないなら
      sentense=true;                  //sentenseをオン
    else
      sentense=false;                 //sentenseをオフ
  }

  if(sentense)                        //sentenseがオンなら
    return hch;                       //そのまま今の文字を返す

  while(hch=='/'){                    //今の文字が'/'なら
    nexthch=getL();                   //次の文字取得
    if(eofflag)                       //eofflagがオンなら
      break;                          //break

    if(nexthch=='/'){                 //次の文字が'/'なら
      nexthch='\0';                   //次の文字を空にする
      while(hch!='\n'){               //改行まで飛ばす
        hch=getL();                   //１文字取得
        if(eofflag)                   //eofflagがオンなら
          return hch;                 //eofであるから改行を返すはず
      }
      break;                          //ループを抜ける(上手くいっていれば今の文字は改行のはず)
    }
    else if(nexthch=='*'){            //次の文字が'*'なら
      nexthch='\0';                   //次の文字を空にする
      commentflag=true;               //commentflagをオン
      while(commentflag){             //commentflagがオンの間
        while(hch!='*'){              //今の文字が'*'出ない間
          if(hch=='\n')               //改行なら
            enterhcnt=enterhcnt+1;    //改行数を加算
          hch=getL();                 //１文字取得
          if(eofflag){                //eofflagがオンなら
            return hch;               //eofであるから改行を返すはず
          }
        }
        hch=getL();                   //'*'の次の文字を取得
        if(eofflag){                  //eofflagがオンなら
          return hch;                 //eofであるから改行を返すはず
        }

        if(hch=='/')                  //'*'の次の文字が'/'なら
           commentflag=false;         //コメント終了 commentflagをオフ
      }
    }
    else                              //次の文字がただの文字だった
      return hch;                     //今の文字を返す

    hch=getL();                       //コメント後にコメントが来ることを予期してもう一周する
    if(eofflag)                       //eofflagがオンなら
      return hch;                     //eofであるから改行を返すはず
  }

  return hch;                         //今の文字を返す
}



char nextwch='\0';                        //getWord()用の次の文字
boolean wordflag=false;                   //今の文字と次の文字がアルファベットかどうかのフラグ
boolean wordspace=false;                  //次の文字が' 'かどうかのフラグ
boolean argspace=false;                   //引数の解析時用のフラグ
boolean linehead=true;                    //行の先頭かどうかのフラグ

//今の文字と次の文字を同時にとり、記号と単語を分ける
//返り値は今の文字だが呼び出した関数は主にフラグをみる
char getWord(){
  char wch;                               //今の文字

  if(nextwch!='\0'){                      //次の文字が空でないなら
    wch=nextwch;                          //今の文字に次の文字を代入
    nextwch='\0';                         //次の文字を空にする
  }
  else{                                   //次の文字が空なら
    wch=getH();                           //今の文字取得
  }

  nextwch=getH();                         //次の文字取得

  if(isAlnum(wch) || wch=='.'){           //今の文字が 0~9 a~z A~Z '.'のどれかなら
    linehead=false;                       //lineheadをオフ
    wordflag=true;                        //wordflagをオン
    if(!isAlnum(nextwch) && nextwch!='.'){//次の文字が記号なら
      if(nextwch=='\"' && !sentense)      //終わりの'\"'なら
        wordflag=true;                    //wordflagをオン
      else                                //始まりの'\"'なら
        wordflag=false;                   //wordflagをオフ
    }
  }
  else if(wch==' ' && !argspace){         //今の文字が' 'なら
    if(linehead){                         //行の先頭なら
      wordspace=false;                    //wordspaceをオフ
        return wch;                       //今の文字を返す（スペース）
    }
    else if(wordspace){                   //wordspaceがオンなら
      wordspace=false;                    //wordspaceをオフ
      while(nextwch==' ')                 //次の文字が' 'の間１つだけ' 'を返して他の' 'は飛ばす
        nextwch=getH();                   //次の文字取得
      return wch;                         //今の文字を返す（スペース）
    }
  }
  else if(wch=='\"'){                     //今の文字が'\"'なら
    if(sentense)                          //sentenseがオンなら
      wordflag=true;                      //wordflagをオン
    else                                  //sentenseがオフなら
      wordflag=false;                     //wordflagをオフ
  }
  else{                                   //今の文字が記号なら
    linehead=false;                       //lineheadをオフ
    wordflag=false;                       //wordflagをオフ
  }

  if(nextwch==' ')                        //次の文字が' 'なら
    wordspace=true;                       //wordspaceをオン

  return wch;                             //今の文字を返す
}



//コメントまたは\\n時の改行の数だけ改行する
//返り値はipbufの位置
int entercount(){
  int i;                                          //bufferの添字
  for(i=0;i<(enterhcnt+enterlcnt);i=i+1){         //改行の数だけループ
    ipbuf[i]='\n';                                //先頭から改行を代入
  }
  enterlcnt=0;                                    //改行数を初期化
  enterhcnt=0;                                    //改行数を初期化
  return i;                                       //現在のbufferの添字を返す
}



boolean lexflag=false;                            //'#'を見つけた時用のフラグ

//字句解析
int lexical(){
  int bufn=0;                                     //現在文字位置
  int wordn=0;                                    //単語の位置
  char buf;                                       //入力文字
  int wordlen;                                    //単語の文字数

  word=malloc(sizeof(char)*INPUTSIZE);            //単語の初期化

  buf=getWord();                                  //１文字取得

  while(wordflag){                                //スペースか改行か記号まで文字を取り出す（ただし'.'は含めておく）
    ipbuf[bufn]=buf;                              //ipbufに現在文字を代入
    word[wordn]=buf;                              //wordに現在文字を代入
    bufn=bufn+1;                                  //現在文字位置をインクリメント
    wordn=wordn+1;                                //現在単語位置をインクリメント
    buf=getWord();                                //文字取得
  }

  if(buf=='\n'){                                  //改行で終わったなら
    bufn=entercount();                            //entercount()を呼び出す
    sentense=false;                               //sentenseをオフ
    linehead=true;                                //lineheadをオン
  }

  ipbuf[bufn]=buf;                                //最後の１文字を代入
  bufn=bufn+1;                                    //現在文字位置をインクリメント
  ipbuf[bufn]='\0';                               //'\0'を代入
  word[wordn]=buf;                                //最後の１文字を代入
  wordn=wordn+1;                                  //現在単語位置をインクリメント
  word[wordn]='\0';                               //'\0'を代入

  wordlen=strLen(word);                           //単語の文字数を取得

  if(lexflag){                                    //'#'があったなら
    if(strCmp(word,"Edefine")==0){                //"#Edefine"なら
      return T_EDEFINE;                           //T_EDEFINEを返す
    }
    else if(strCmp(word,"Sdefine")==0){           //"#Sdefine"なら
      return T_SDEFINE;                           //T_SDEFINEを返す
    }
    else if(strCmp(word,"include")==0){           //"#include"なら
      return T_INCLUDE;                           //T_INCLUDEを返す
    }
    else if(strCmp(word,"else")==0){              //"#else"なら
      return T_ELSE;                              //T_ELSEを返す
    }
    else if(strCmp(word,"ifdef")==0){             //"#ifdef"なら
      return T_IFDEF;                             //T_IFDEFを返す
    }
    else if(strCmp(word,"ifndef")==0){            //"#ifndef"なら
      return T_IFNDEF;                            //T_IFNDEFを返す
    }
    else if(strCmp(word,"elseifdef")==0){         //"#elseifdef"なら
      return T_ELSEIFDEF;                         //T_ELSEIFDEFを返す
    }
    else if(strCmp(word,"elseifndef")==0){        //"#elseifndef"なら
      return T_ELSEIFNDEF;                        //T_ELSEIFNDEFを返す
    }
    else if(strCmp(word,"endif")==0){             //"#endif"なら
      return T_ENDIF;                             //T_ENDIFを返す
    }
    else if(strCmp(word,"undef")==0){             //"#undef"なら
      return T_UNDEF;                             //T_UNDEFを返す
    }
  }
  if(word[0]=='\'' && word[wordlen-1]=='\''){     //'x'なら
    return T_MOJI;                                //T_MOJIを返す
  }
  else if(word[0]=='\"' && word[wordlen-1]=='\"'){//"..."なら
    return T_MOJI;                                //T_MOJIを返す
  }
  return T_OTHER;                                 //ただの文字ならT_OTHERを返す
}



//' 'をスキップする関数
//返り値は単語タイプ
int skipspace(){
  int type;                                       //字句解析タイプ
  type=lexical();                                 //単語取得
  while(strCmp(word," ")==0)                      //" "の間ループ
    type=lexical();                               //単語取得
  return type;                                    //typeを返す
}



//引数用字句解析
//引数の場合" "や()の数を保存するため、字句解析を分けた
char[] lexarg(){
  int parentcnt=0;                                //()の数
  char[] arg;                                     //引数文字列
  arg=malloc(sizeof(char)*ARGSIZE);               //引数文字列の初期化

  lexical();                                      //単語取得
  arg=strCpy(arg,"\0");                           //引数の先頭に'\0'を代入
  while(true){                                    //breakまでループ
    if(strCmp(word,",")==0 && parentcnt==0)       //()がなく、単語が','なら
      break;                                      //1つの引数の終わり
    if(strCmp(word,")")==0 && parentcnt==0)       //()がなく、単語が')'なら
      break;                                      //引数の終わりの')'
    if(strCmp(word,"\n")==0 || eofflag){          //eofまたは改行なら
//引数が途中で切れているエラー
      break;
    }
    if(strCmp(word,"(")==0)                       //'('なら
      parentcnt=parentcnt+1;　                    //parentcntを加算
    else if(strCmp(word,")")==0)                  //')'なら
      parentcnt=parentcnt-1;                      //parentcntを減算
    arg=strCat(arg,word);                         //引数文字列に単語を追加
    lexical();                                    //単語取得
  }
  return arg;                                     //引数を返す
}



int narg;                                         //引数数

//(x,y)とかの引数の取り出し
//返り値は引数
char[][] getArg(){
  char[][] args;                                  //引数を持つ２次元配列
  narg=0;                                         //引数数の初期化
  argspace=true;                                  //引数の解析をするフラグ

  args=malloc(sizeof(char[])*ARGSIZE);            //引数配列の初期化

  lexical();                                      //単語取得
  if(strCmp(word,"(")==0){                        //単語が'('なら
    args[narg]=lexarg();                          //１つ引数を取得
    narg=narg+1;                                  //引数数を加算
    while(strCmp(word,",")==0){                   //現在単語が','である間
      args[narg]=lexarg();                        //引数を取得
      narg=narg+1;                                //引数数を加算
    }
    if(strCmp(word,")")!=0)                       //単語が')'でないなら
//引数が正しく終わっていないエラー
      narg=narg;
  }

  args[narg]=null;                                //引数配列の終わりをnullにする
  argspace=false;                                 //argspaceをオフ

  return args;                                    //引数配列を返す
}



//定義本体の取得
//定義本体の引数の位置やマクロ名の入子を処理する
//返り値は定義本体
char[] getDef(char[] mname,char[][] arg){
  char[] buffer=malloc(sizeof(char)*INPUTSIZE);   //
  int wordn=0;                                    //単語の出現番号、引数の出現時に使う
  char[] submacro;                                //途中で見つけたマクロ名を保持
  char[][] subarg;                                //定義本体中のマクロの引数
  int subnarg=narg;                               //引数数を保持

  skipspace();                                    //スペースをスキップ

  while(word[0]!='\n'){                           //改行までループ
    int i=0;
    for(i=0;i<subnarg;i=i+1){                     //引数と同じかどうかのループ
      if(strCmp(arg[i],word)==0){                 //引数と同じなら
        if(makelist(mname,i,wordn)==-1)           //リストに登録
//リストの登録不可のエラー
          return null;
      }
    }

    if(i==subnarg){                               //引数でないなら
      int n=searchdef(word);                      //マクロ名を探索
      if(n!=-1){                                  //マクロ名なら
        submacro=word;                            //マクロ名保持
        if(deftable[n].narg==0){                  //マクロ名の引数数が0なら
          subarg=malloc(sizeof(char[])*1);        //マクロの引数を初期化
          subarg[0]=null;                         //引数にnullを代入
        }
        else{                                     //引数数が0でない
          subarg=getArg();                        //引数を取得
        }
        ipbuf=replacedef(submacro,subarg);        //マクロを展開
      }
    }

    buffer=strCat(buffer,ipbuf);                  //bufferに追加
    lexical();                                    //単語取得
    wordn=wordn+1;                                //単語の出現番号を加算
  }
  buffer=strCat(buffer,"\0");                     //bufferに'\0'を代入
  return buffer;                                  //bufferを返す
}



char[] macroname;                                 //マクロ名

//マクロ名を登録する前の前処理
//返り値はマクロの引数の多次元配列
char[][] do_makeMname(){
  int type=0;                                     //文字タイプ
  char[][] args;                                  //引数用２次元配列

  if(eofflag)                                     //eofflagがオンなら
//マクロの定義が正常に終わっていないエラー
    return null;

  type=skipspace();                               //スペースをスキップ
  macroname=word;                                 //マクロ名を保持

  if(type==T_OTHER){                              //文字タイプがただの文字なら
    if(isAlpha(word[0])){                         //マクロ名の最初の文字がアルファベットなら
      args=getArg();                              //引数を取得
      int i=0;
      for(i=0;i<narg;i=i+1){                      //引数の数だけループ
        if(!isAlpha(args[i][0]))                  //引数の最初の文字がアルファベットでないなら
//引数名不可エラー
          return null;
      }
      if(makemacro(macroname,narg)==-1)           //マクロ名の登録
//登録不可のエラー
        return null;
    }
    else{                                         //マクロ名の最初がアルファベットでないなら
//アルファベットから始まらないマクロ名不可エラー
      return null;
    }
  }
  else{                                           //マクロ名が特殊な単語なら
//特殊なマクロ名不可エラー
    return null;
  }
  return args;                                    //マクロの引数を返す
}



//#Edefineを見つけた
int do_Edefine(){
  char[][] args;                                //引数用２次元配列

  args=do_makeMname();                          //so_makeMname()呼び出し
  if(args==null)                                //引数がnullなら
//何かしらエラーがあった
    return -1;

  char[] def=malloc(sizeof(char)*INPUTSIZE);    //定義本体用バッファ初期化


  def=getDef(macroname,args);                   //定義本体取得
  if(def==null)                                 //定義本体がないなら
//定義本体がないエラー
    return -1;

  int i=0;
  int cnt=1;                                    //()の数
  if(def[0]=='('){                              //定義本体の先頭が'('なら
    for(i=1;def[i]!='\0';i=i+1){                //定義本体の終わりまでループ
      if(def[i]=='(')                           //'('があったら
        cnt=cnt+1;                              //カウントを加算
      else if(def[i]==')')                      //')'があったら
        cnt=cnt-1;                              //カウントを減算
      if(cnt==0)                                //カウントが0なら
        break;                                  //ループを抜ける
    }
    if(def[i+1]!='\0')                          //定義本体の最後までいっていないなら
//()の数エラー
      return -1;
  }
  else                                          //定義本体の先頭が'('でないなら
//Edefineの仕様に反するエラー
    return -1;

  if(makedef(macroname,def)==-1)                //定義本体の登録
//定義本体の登録不可エラー
    return -1;

  return 0;                                     //正常終了
}



//#Sdefineを見つけた
int do_Sdefine(){
  char[][] args;                                //引数用二次元配列
  args=do_makeMname();                          //do_makeMname()を呼び出す
  if(args==null)                                //引数がnullなら
//何かしらのエラー
    return -1;

  char[] def=malloc(sizeof(char)*INPUTSIZE);    //定義本体用バッファ

  def=getDef(macroname,args);                   //定義本体取り出し
  if(def==null)                                 //定義本体がないなら
//定義本体がないエラー
    return -1;

  if(makedef(macroname,def)==-1)                //定義本体の登録
//定義本体登録不可エラー
    return -1;

  return 0;                                     //正常終了
}



#define LINEC(l) #l                                         //行数を文字列にするため
//# 行番号　ファイル名を出力
void lineoutput(){
  int len=0;                                                //文字列の長さ
  fputc('#',op);                                            //'#'を印字
  fputc(' ',op);                                            //スペースを印字
  char[] linec=LINEC(linenum);                              //行数を文字列化
  len=strLen(linec);                                        //行数の長さ取得
  int i=0;
  for(i=0;i<len;i=i+1)                                      //文字数だけループ
    fputc(linec[i],op);                                     //行数印字
  fputc(' ',op);                                            //スペース印字
  fputc('\"',op);                                           //'\"'を印字
  len=strLen(incdepth[isp].name);                           //ファイル名の長さ取得
  for(i=0;i<len;i=i+1)                                      //文字数だけループ
    fputc(incdepth[isp].name[i]);                           //ファイル名印字
  fputc('\"',op);                                           //'\"'を印字
  fputc('\n',op);                                           //改行
}

//#includeを見つけた
int do_include(){
  int type;                                               //単語タイプ
  char[] includename=malloc(sizeof(char)*INCLUDENAME);    //includeのファイル名

  type=skipspace();                                       //スペースをスキップ
  if(type==T_MOJI){                                       //"..."なら
    int i=0;
    if(word[i]=='\'')                                     //'x'なら
//"..."ではない記述エラー
    for(i=1;word[i]!='\"';i=i+1)                          //"..."の...の間
      includename[i-1]=word[i];                           //ファイル名として保存
  }
  else if(word[0]=='<'){                                  //<...>なら
    lexical();                                            //単語取得
    while(word[0]!='>'){                                  //'>'までループ
      includename=strCat(includename,word);               //ファイル名として追加
      lexical();                                          //単語取得
    }
  }
  else                                                    //"..."でも<...>でもないなら
//includeの記述に反するエラー

  lexical();                                              //１単語取得
  if(strCmp(word,"\n")!=0){                               //改行でないなら
    lexical();                                            //１単語取得
//#includeの記述に反するwarning
    while(strCmp(word,"\n")!=0)                           //改行でない間
      lexical();                                          //１単語取得
  }
  saveincdepth(linenum,byteh,bytel);                      //今のファイル名の読み込みバイト数と行すうを保存
  isp=makeincdepth(includename);                          //includeのファイル名を登録
  fd=fopen(incdepth[isp].name,"r");                       //includeのファイル名でオープン
  byteh=0;                                                //bytehの初期化
  bytel=0;                                                //bytelの初期化
  linenum=1;                                              //linenumの初期化
  lineoutput();                                           //ファイルの始まりを印字
  return 0;                                               //正常終了
}



//#ifdefを見つけた
int do_ifdef(int con){
  elseflag=false;                             //elseflagをオフ
  if(ifdepth[sp]==1){                         //今のif条件が成立なら
    sp=sp+1;                                  //spを加算
    if(con==1){                               //条件が成立するなら
      ifdepth[sp]=1;                          //成立を表す
      elseflag=true;                          //elseflagをオン
    }
    else{                                     //条件が不成立なら
      ifdepth[sp]=0;                          //不成立を表す
    }
  }
  else{                                       //今のif条件が不成立なら
    sp=sp+1;                                  //spを加算
    ifdepth[sp]=0;                            //不成立を表す
  }
  return 0;                                   //正常終了
}



//#ifndefを見つけた
int do_ifndef(int con){
  elseflag=false;                             //elseflagをオフ
  if(ifdepth[sp]==1){                         //今のif条件が成立なら
    sp=sp+1;                                  //spを加算
    if(con==0){                               //条件が成立するなら
      ifdepth[sp]=1;                          //成立を表す
      elseflag=true;                          //elseflagをオン
    }
    else{                                     //条件が不成立なら
      ifdepth[sp]=0;                          //不成立を表す
    }
  }
  else{                                       //今のif条件が不成立なら
    sp=sp+1;                                  //spを加算
    ifdepth[sp]=0;                            //不成立を表す
  }
  return 0;                                   //正常終了
}



//#elseを見つけた
int do_else(){
  if(ifdepth[sp-1]==1){                       //１つ上のif条件が成立しているなら
    if(ifdepth[sp]==1 || elseflag){           //今の条件が成立またはelseflagがオンなら
      ifdepth[sp]=0;                          //不成立を表す
    }
    else{                                     //今条件が不成立かつelseflagがオフなら
      ifdepth[sp]=1;                          //成立を表す
    }
  }
  else{                                       //1つ上のif条件が不成立なら
    ifdepth[sp]=0;                            //不成立を表す
  }
  return 0;                                   //正常終了
}



//#elseifdefを見つけた
int do_elseifdef(int con){
  if(ifdepth[sp-1]==1){                       //１つ上のif条件が成立しているなら
    if(elseflag){                             //elseflagがオンなら
      ifdepth[sp]=0;                          //不成立を表す
    }
    else{                                     //elseflagがオフなら
      if(con==1){                             //条件が成立なら
        ifdepth[sp]=1;                        //成立を表す
        elseflag=true;                        //elseflagをオン
      }
      else{                                   //条件が不成立なら
        ifdepth[sp]=0;                        //不成立を表す
      }
    }
  }
  else{                                       //1津上のif条件が不成立なら
    ifdepth[sp]=0;                            //不成立を表す
  }
  return 0;                                   //正常終了
}



//＃elseifんでfを見つけた
int do_elseifndef(int con){
  if(ifdepth[sp-1]==1){                       //１つ上のif条件が成立しているなら
    if(elseflag){                             //elseflagがオンなら
      ifdepth[sp]=0;                          //不成立を表す
    }
    else{                                     //elseflagがオフなら
      if(con==0){                             //条件が成立するなら
        ifdepth[sp]=1;                        //成立を表す
        elseflag=true;                        //eofflagをオン
      }
      else{                                   //条件が不成立なら
        ifdepth[sp]=0;                        //不成立を表す
      }
    }
  }
  else{                                       //１つ上のif条件が不成立なら
    ifdepth[sp]=0;                            //不成立を表す
  }
  return 0;                                   //正常終了
}



//#endifを見つけた
int do_endif(){
  ifdepth[sp]=0;                              //条件を初期化
  sp=sp-1;                                    //spwp減算
  if(sp<0)                                    //spが負の値なら
//#ifと#endifの数が合わないエラー
  return -1;
  elseflag=false;                             //elseflagをオフ
  return 0;                                   //正常終了
}



//#ifなどの条件チェック
int conditioncheck(){
  skipspace();                                //スペースをスキップ
  int n=searchdef(word);                      //マクロ名探索
  if(n>-1)                                    //マクロ名が見つかったなら
    return 1;                                 //1を返す
  return 0;                                   //マクロ名なしなら0を返す
}



//#undefを見つけた
int do_undef(){
  skipspace();                                //スペースをスキップ
  if(deletedef(word)==-1)                     //マクロ名を消去
//消去不可のエラー
    return -1;
  return 0;                                   //正常終了
}


void do_error(){

}


void construction(){

}



//単語の'.'より前の部分のみを取り出す
char[] dotdelete(char[] str){
  int bufn=0;                                 //単語の位置
  int rbufn=0;                                //返り値用バッファの位置
  char[] ret=malloc(sizeof(char)*strLen(str));//バッファの初期化
  for(bufn=0;str[bufn]!='.';bufn=bufn+1){     //'.'までループ
    ret[rbufn]=str[bufn];                     //返り値用バッファに代入
    rbufn=rbufn+1;                            //文字位置を加算
  }
  ret[rbufn]='\0';                            //'\0'を代入
  return ret;                                 //バッファを返す
}



public int main(int argc,char[][] argv){
  char[] bufer;                               //マクロ展開時用バッファ
  char[] opname;                              //出力ファイル名
  int linen=1;                                //行番号
  char buf;                                   //現在文字
  int bufn;                                   //現在文字位置
  int type;                                   //字句解析タイプ
  int condition;                              //条件のコンディション

  isp=makeincdepth(argv[1]);                  //ソースファイルをテーブルに追加
  fd=fopen(incdepth[isp].name,"r");           //入力ファイルオープン
  lineoutput();                               //ファイルの始まり
  opname=dotdelete(argv[1]);                  //出力ファイル名の'.'以前を取得
  opname=strCat(opname,".i\0");               //出力ファイル名作成
  op=fopen(opname,"w");                       //出力ファイルオープン

  char[][] subarg;                            //引数用２次元配列
  char[] submacro;                            //マクロ名
  ifdepth[sp]=1;                              //ifdepthの最初は常に１

  while(!feof(fd)){                           //入力ファイルから単語を読み込み
    type=lexical()                            //入力の単語のタイプ
    if(word[0]=='#'){                         //'#'を見つけたなら
      lexflag=true;                           //lexflagをオン
      continue;                               //ループの最初に戻る
    }
    if(ifdepth[sp]==1){                       //#if #elseの条件が成立している
      if(type==T_MOJI || type==T_OTHER){      //"..."または'x'またはただの単語なら
        if(lexflag){                          //'#'を見つけていたら
          fputc('#',op);                      //'#'を印字
          int i=0;
          for(i=0;ipbuf[i]!='\0';i=i+1)       //bufferの終わりまでループ
            fputc(ipbuf[i],op);               //bufferを印字
          lexflag=false;                      //lexflagをオフ
          continue;                           //ループの最初に戻る
        }
        int n=searchdef(word);                //マクロ名を探索
        if(n!=-1){                            //マクロ名なら
          submacro=word;                      //マクロ名を保持
          subarg=getArg();                    //引数を取得
          ipbuf=replacedef(submacro,subarg);  //bufferにマクロを展開
        }
        int i=0;
        for(i=0;ipbuf[i]!='\0';i=i+1)         //buffreの終わりまでループ
          fputc(ipbuf[i],op);                 //bufferを印字
      }
      else if(type==T_EDEFINE){               //#Edefineなら
        lexflag=false;                        //lexflagをオフ
        fputc('\n',op);                       //改行を印字
        do_Edefine();                         //do_Edefine()呼び出し
      }
      else if(type==T_SDEFINE){               //#Sdefineなら
        lexflag=false;                        //lexflagをオフ
        fputc('\n',op);                      //改行を印字
        do_Sdefine();                         //do_Sdefine()呼び出し
      }
      else if(type==T_INCLUDE){               //#includeなら
        lexflag=false;                        //lexflagをオフ
        do_include();                         //do_include()呼び出し
      }
      else if(type==T_UNDEF){                 //#undefなら
        lexflag=false;                        //lexflagをオフ
        fputc('\n',op);                       //改行を印字
        do_undef();                           //do_undef()呼び出し
      }
    }
    else{                                     //#if #elseの条件が不成立なら
      lexflag=false;                          //lexflagをオフ
      if(strCmp(word,"\n")==0)                //今の単語が'\n'なら
        fputc('\n',op);                       //改行を印字
    }

    if(type==T_ELSE){                         //#elseなら
      lexflag=false;                          //lexflagをオフ
      do_else();                              //do_else()呼び出し
    }
    else if(type==T_IFDEF){                   //#ifdefなら
      lexflag=false;                          //lexflagをオフ
      condition=conditioncheck();             //条件をチェック
      do_ifdef(condition);                    //do_ifdef()呼び出し
    }
    else if(type==T_IFNDEF){                  //#ifndefなら
      lexflag=false;                          //lexflagをオフ
      condition=conditioncheck();             //条件をチェック
      do_ifndef(condition);                   //do_ifndef()呼び出し
    }
    else if(type==T_ELSEIFDEF){               //#elseifdefなら
      lexflag=false;                          //lexflagをオフ
      condition=conditioncheck();             //条件をチェック
      do_elseifdef(condition);                //do_elseifdef()呼び出し
    }
    else if(type==T_ELSEIFNDEF){              //#elseifndefなら
      lexflag=false;                          //lexflagをオフ
      condition=conditioncheck();             //条件をチェック
      do_elseifndef(condition);               //do_elseifndef()呼び出し
    }
    else if(type==T_ENDIF){                   //#endifなら
      lexflag=false;                          //lexflagをオフ
      do_endif();                             //do_endif()呼び出し
    }

    if(feof(fd) && isp!=0){                   //今見ているファイルがeofでincludeテーブルのスタックポインタが１番下でないなら
      fclose(fd);                             //今見ているファイルをクローズ
      isp=deleteincdepth(incdepth[isp].name); //includeテーブルを１つ削除
      fd=fopen(incdepth[isp].name,"r");       //前のファイルをオープン
      fseek(fd,incdepth[isp].dbyteh,incdepth[isp].dbytel);  //元の位置に移動
      byteh=incdepth[isp].dbyteh;             //dbytehを取得
      bytel=incdepth[isp].dbytel;             //dbytelを取得
      linenum=incdepth[isp].linen;            //linenumを取得
      lineoutput();                           //ファイルの始まり
    }
  }
  fclose(fd);                                 //入力ファイルをクローズ
  fclose(op);
  return 0;
}

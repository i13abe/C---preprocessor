#include <stdio.hmm>
#include <stdlib.hmm>
#include <string.hmm>
#include <ctype.hmm>
#include "type.hmm"
#include "definition.hmm"
#include "including.hmm"

#define INPUTSIZE 50
#define ARGSIZE 10         //マクロの引数数。内一つはnull用
#define TABLESIZE 20
#define INDEPTHSIZE 10
#define INCLUDENAME 20

public definition[] deftable=array(TABLESIZE);
public filelist[] incdepth=array(INDEPTHSIZE);
FILE fd;
boolean eofflag=false;
char[] ipbuf=array(INPUTSIZE);
char[] word;
int isp=0;
int bytel=0;
int byteh=0;
int linenum=1;


void byteplus(){
  if(bytel==32767){
    byteh=byteh+sizeof(char);
    bytel=0;
  }
  else{
    bytel=bytel+sizeof(char);
  }
}

int enterlcnt=0;         //改行の数
char nextlch='\0';      //getL()用の次文字
// \\nを無視する１文字入力
char getL(){
  char lch;
  if(nextlch!='\0' && nextlch!='\\'){
    lch=nextlch;
    nextlch='\0';
    byteplus();
    return lch;
  }
  if(nextlch=='\\'){
    lch='\\';
  }
  else{
    lch=fgetc(fd);
    byteplus();
  }

  while(lch=='\\'){
    if(!feof(fd)){
      nextlch=fgetc(fd);
    }
    else{
      eofflag=true;
      return '\n';
    }
    if(nextlch=='\n'){
      linenum=linenum+1;
      if(!feof(fd)){
        do{
          lch=fgetc(fd);
          byteplus();
          if(feof(fd)){
            eofflag=true;
            return '\n';
          }
        }while(lch==' ');
      }
      else{
        eofflag=true;
        return '\n';
      }
      enterlcnt=enterlcnt+1;
      nextlch='\0';
    }
    else
      return lch;
  }
  if(lch=='\n')
    linenum=linenum+1;

  return lch;
}



int enterhcnt=0;        //改行の数
char nexthch='\0';      //getH()用の次文字
boolean sentense=false;
// コメントを削除する１文字入力
char getH(){
  char hch;
  int commentflag=0;

  if(nexthch!='\0'){
    hch=nexthch;
    nexthch='\0';
    return hch;
  }

  hch=getL();

  //今の文字が'\"'なら
  if(hch=='\"'){
    if(!sentense)
      sentense=true;
    else
      sentense=false;
  }

  if(sentense)
    return hch;

  //最初に'/'を見つけた
  while(hch=='/'){
    nexthch=getL();
    if(eofflag)
      break;

    //次の文字が'/'だった
    if(nexthch=='/'){
      nexthch='\0';
      while(hch!='\n'){
        hch=getL();
        if(eofflag)
          return '\n';
      }
      break;
    }

    //次の文字が'*'だった
    else if(nexthch=='*'){
      nexthch='\0';
      commentflag=1;
      while(commentflag==1){
        while(hch!='*'){
          if(hch=='\n')
            enterhcnt=enterhcnt+1;
          hch=getL();
          if(eofflag){

            printf("コメントエラー\n");
            return '\n';
          }
        }
        hch=getL();
        if(eofflag){

          printf("コメントエラー\n");
          return '\n';
        }
        if(hch=='/')
           commentflag=0;
      }
    }

    //次の文字がただの文字だった
    else
      return hch;

    hch=getL();
    if(eofflag)
      return hch;
  }

  return hch;
}



char nextwch='\0';        //次の文字を取得する
boolean wordflag=false;   //今の文字と次の文字がアルファベットならtrue
boolean wordspace=false;  //次の文字が' 'になった時true
boolean argspace=false;   //引数の解析時のフラグ
boolean linehead=true;    //行の先頭ならtrue
//今の文字と次の文字を同時にとり、記号と単語を分ける
//返り値は今の文字だが呼び出した関数は主にフラグをみる
char getWord(){
  char wch;     //今の文字

  //次の文字が空でなかったら今の文字に入れる
  if(nextwch!='\0'){
    wch=nextwch;
    nextwch='\0';
  }

  //次の文字が空だったら今の文字を取得
  else{
    wch=getH();
  }

  nextwch=getH();   //次の文字取得

  //今の文字が 0~9 a~z A~Z '.'のどれかか
  if(isAlnum(wch) || wch=='.'){
    linehead=false;       //行の先頭フラグをオン
    wordflag=true;        //単語であるのでフラグをオン

    //次の文字が記号なら
    if(!isAlnum(nextwch) && nextwch!='.'){
      //終わりの'\"'なら
      if(nextwch=='\"' && !sentense)
        wordflag=true;      //フラグをオン
      else
        wordflag=false;     //フラグをオフ
    }
  }

  //今の文字が' 'なら
  else if(wch==' ' && !argspace){
    //行の先頭ならそのまま' 'を返す
    if(linehead){
      wordspace=false;
        return wch;
    }

    //フラグがオンなら１つだけ' 'を返して他の' 'は飛ばす
    else if(wordspace){
      wordspace=false;
      while(nextwch==' ')
        nextwch=getH();
      return wch;
    }
  }

  //今の文字が'\"'なら
  else if(wch=='\"'){
    if(sentense)
      wordflag=true;
    else
      wordflag=false;
  }

  //今の文字が記号ならフラグをオフ
  else{
    linehead=false;
    wordflag=false;
  }

  //次の文字が' 'ならフラグをオン
  if(nextwch==' ')
    wordspace=true;

  return wch;
}



//コメントまたは\\n時の改行の数だけ改行する
//返り値はipbufの位置
int entercount(){
  int i;
  for(i=0;i<(enterhcnt+enterlcnt);i=i+1){
    ipbuf[i]='\n';
  }
  enterlcnt=0;
  enterhcnt=0;
  return i;
}


boolean lexflag=false;
//字句解析
int lexical(){
  int bufn=0;                   //現在文字位置
  int wordn=0;                   //単語の位置
  char buf;                     //入力文字

  word=malloc(sizeof(char)*INPUTSIZE);

  buf=getWord();

  //スペースか改行か記号まで文字を取り出す
  //ただし'.'は含めておく
  while(wordflag){
    ipbuf[bufn]=buf;
    word[wordn]=buf;
    bufn=bufn+1;
    wordn=wordn+1;
    buf=getWord();
  }

  //改行で終わったなら行先頭フラグを立てる
  if(buf=='\n'){
    bufn=entercount();
    sentense=false;
    linehead=true;
  }


  ipbuf[bufn]=buf;
  bufn=bufn+1;
  ipbuf[bufn]='\0';
  word[wordn]=buf;
  wordn=wordn+1;
  word[wordn]='\0';

  int wordlen=strLen(word);

  //字句解析
  if(lexflag){
    if(strCmp(word,"Edefine")==0){
      return T_EDEFINE;
    }
    else if(strCmp(word,"Sdefine")==0){
      return T_SDEFINE;
    }
    else if(strCmp(word,"include")==0){
      return T_INCLUDE;
    }
    else if(strCmp(word,"else")==0){
      return T_ELSE;
    }
    else if(strCmp(word,"ifdef")==0){
      return T_IFDEF;
    }
    else if(strCmp(word,"ifndef")==0){
      return T_IFNDEF;
    }
    else if(strCmp(word,"elseifdef")==0){
      return T_ELSEIFDEF;
    }
    else if(strCmp(word,"elseifndef")==0){
      return T_ELSEIFNDEF;
    }
    else if(strCmp(word,"endif")==0){
      return T_ENDIF;
    }
    else if(strCmp(word,"undef")==0){
      return T_UNDEF;
    }
  }

  if(word[0]=='\'' && word[wordlen-1]=='\''){
    return T_MOJI;
  }
  else if(word[0]=='\"' && word[wordlen-1]=='\"'){
    return T_MOJI;
  }
  return T_OTHER;
}


int skipspace(){
  int type;
  lexical();
  while(strCmp(word," ")==0)
    type=lexical();
  return type;
}


char[] lexarg(){
  int parentcnt=0;
  char[] arg;
  arg=malloc(sizeof(char)*ARGSIZE);

  lexical();
  arg=strCpy(arg,"\0");
  while(true){
    if(strCmp(word,",")==0 && parentcnt==0)
      break;
    if(strCmp(word,")")==0 && parentcnt==0)
      break;
    if(strCmp(word,"\n")==0 || eofflag){
      //T_ERROR
      break;
    }
    if(strCmp(word,"(")==0)
      parentcnt=parentcnt+1;
    else if(strCmp(word,")")==0)
      parentcnt=parentcnt-1;
    arg=strCat(arg,word);
    lexical();
  }
  return arg;
}


//(x,y)とかの引数の取り出し
//返り値は引数
int narg;     //引数数
char[][] getArg(){
  char[][] args;      //引数を持つ配列
  narg=0;             //引数の数
  argspace=true;

  args=malloc(sizeof(char[])*ARGSIZE);

  lexical();
  if(strCmp(word,"(")==0){
    args[narg]=lexarg();
    narg=narg+1;
    while(strCmp(word,",")==0){
      args[narg]=lexarg();
      narg=narg+1;
    }
    if(strCmp(word,")")!=0)
      //error
      narg=narg;
  }

  args[narg]=null;
  argspace=false;

  return args;
}



//定義本体の取得
//定義本体の引数の位置やマクロ名の入子を処理する
//返り値は定義本体
char[] getDef(char[] mname,char[][] arg){
  char[] buffer=malloc(sizeof(char)*INPUTSIZE);
  int wordn=0;          //単語の出現番号、引数の出現時に使う
  char[] submacro;      //途中で見つけたマクロ名を保持
  char[][] subarg;      //定義本体中のマクロの引数
  int subnarg=narg;     //引数数を保持

  skipspace();

  while(word[0]!='\n'){

    //引数と同じならリストに登録
    int i=0;
    for(i=0;i<subnarg;i=i+1){
      if(strCmp(arg[i],word)==0){
        if(makelist(mname,i,wordn)==-1)
          return null;
      }
    }

    //引数でないならマクロ名かどうかを比較
    if(i==subnarg){
      int n=searchdef(word);
      if(n!=-1){
        submacro=word;
        if(deftable[n].narg==0){
          subarg=malloc(sizeof(char[])*1);
          subarg[0]=null;
        }
        else{
          subarg=getArg();
        }
        ipbuf=replacedef(submacro,subarg);
      }
    }

    buffer=strCat(buffer,ipbuf);
    lexical();
    wordn=wordn+1;
  }
  buffer=strCat(buffer,"\0");
  return buffer;
}




//マクロ名を登録する前の前処理
//返り値はマクロの引数の多次元配列
char[] macroname;
char[][] do_makeMname(){
  int type=0;   //文字タイプ
  char[][] args;

  //マクロの定義ができずに終了
  if(feof(fd))
    return null;

  type=skipspace();
  macroname=word;


  //文字タイプがただの文字かどうか
  if(type==T_OTHER){
    //マクロ名の最初の文字がアルファベットかどうか
    if(isAlpha(word[0])){
      args=getArg();           //引数の配列
      int i=0;
      for(i=0;i<narg;i=i+1){
        //引数の最初の文字がアルファベットかどうか
        if(!isAlpha(args[i][0]))
          //引数名不可
          return null;
      }

      if(makemacro(macroname,narg)==-1) //マクロ名の登録
        return null;
    }
    else{
      //アルファベットから始まらないマクロ名不可
      return null;
    }
  }
  else{
    //特殊なマクロ名不可
    return null;
  }
  return args;
}


//#Edefineを見つけた
int do_Edefine(){
  char[][] args;               //引数

  args=do_makeMname();
  if(args==null)
    return -1;

  char[] def=malloc(sizeof(char)*INPUTSIZE);  //定義本体用バッファ


  def=getDef(macroname,args);             //定義本体取り出し
  if(def==null)         //定義本体がないなら
    return -1;

  int i=0;
  int cnt=1;
  if(def[0]=='('){
    for(i=1;def[i]!='\0';i=i+1){
      if(def[i]=='(')
        cnt=cnt+1;
      else if(def[i]==')')
        cnt=cnt-1;

      if(cnt==0)
        break;
    }
    if(def[i+1]!='\0')
      return -1;
  }
  else
    return -1;

  if(makedef(macroname,def)==-1)  //定義本体の登録
    return -1;
  return 0;
}



int do_Sdefine(){
  char[][] args;
  args=do_makeMname();
  if(args==null)
    return -1;

  char[] def=malloc(sizeof(char)*INPUTSIZE);  //定義本体用バッファ

  def=getDef(macroname,args);             //定義本体取り出し
  if(def==null)         //定義本体がないなら
    return -1;

  if(makedef(macroname,def)==-1)  //定義本体の登録
    return -1;
  return 0;
}

int do_undef(){
  skipspace();
  if(deletedef(word)==-1)
    return -1;
  return 0;
}



int do_include(){
  int type;
  char[] includename=malloc(sizeof(char)*INCLUDENAME);

  type=skipspace();
  if(type==T_MOJI){
    int i=0;
    for(i=1;word[i]!='\"';i=i+1)
      includename[i-1]=word[i];
  }
  else if(word[0]=='<'){
    lexical();
    while(word[0]!='>'){
      includename=strCat(includename,word);
      lexical();
    }
  }
  saveincdepth(linenum,byteh,bytel);
  isp=makeincdepth(includename);
  fd=fopen(incdepth[isp].name,"r");
  byteh=0;
  bytel=0;
  linenum=0;
  return 0;
}



#define IFDEPTH 10
int[] ifdepth=array(IFDEPTH);
int sp=0;
boolean elseflag=false;

int conditioncheck(){
  skipspace();
  int n=searchdef(word);
  if(n>-1)
    return 1;
  return 0;
}

int do_ifdef(int con){
  elseflag=false;
  if(ifdepth[sp]==1){
    sp=sp+1;
    if(con==1){
      ifdepth[sp]=1;
      elseflag=true;
    }
    else{
      ifdepth[sp]=0;
    }
  }
  else{
    sp=sp+1;
    ifdepth[sp]=0;
  }
  return 0;
}

int do_else(){
  if(ifdepth[sp-1]==1){
    if(ifdepth[sp]==1 || elseflag){
      ifdepth[sp]=0;
    }
    else{
      ifdepth[sp]=1;
    }
  }
  else{
    ifdepth[sp]=0;
  }
  return 0;
}

int do_ifndef(int con){
  elseflag=false;
  if(ifdepth[sp]==1){
    sp=sp+1;
    if(con==0){
      ifdepth[sp]=1;
      elseflag=true;
    }
    else{
      ifdepth[sp]=0;
    }
  }
  else{
    sp=sp+1;
    ifdepth[sp]=0;
  }
  return 0;
}

int do_elseifdef(int con){
  if(elseflag){
    if(ifdepth[sp]==1){
      ifdepth[sp]=0;
    }
    else{
      if(con==1){
        ifdepth[sp]=1;
        elseflag=true;
      }
      else{
        ifdepth[sp]=0;
      }
    }
  }
  else{
    ifdepth[sp]=0;
  }
  return 0;
}

int do_elseifndef(int con){
  if(elseflag){
    if(ifdepth[sp]==1){
      ifdepth[sp]=0;
    }
    else{
      if(con==0){
        ifdepth[sp]=1;
        elseflag=true;
      }
      else{
        ifdepth[sp]=0;
      }
    }
  }
  else{
    ifdepth[sp]=0;
  }
  return 0;
}

int do_endif(){
  ifdepth[sp]=0;
  sp=sp-1;
  elseflag=false;
  return 0;
}

char[] dotdelete(char[] str){
  int bufn=0;
  int rbufn=0;
  char[] ret=malloc(sizeof(char)*strLen(str));
  for(bufn=0;str[bufn]!='.';bufn=bufn+1){
    ret[rbufn]=str[bufn];
    rbufn=rbufn+1;
  }
  ret[rbufn]='\0';
  return ret;
}

public int main(int argc,char[][] argv){
  isp=makeincdepth(argv[1]);
  fd=fopen(incdepth[isp].name,"r");
  char[] opname;
  opname=dotdelete(argv[1]);
  opname=strCat(opname,".i\0");


  int type;
  int condition;
  char[]  submacro;
  char[][] subarg;
  ifdepth[sp]=1;    //ifdepthの最初は常に１

  while(!feof(fd)){
    type=lexical();
    if(word[0]=='#'){
      lexflag=true;
      continue;
    }

    if(ifdepth[sp]==1){
      if(type==T_OTHER || type==T_MOJI){
        if(lexflag){
          putchar('#');
          int i=0;
          for(i=0;ipbuf[i]!='\0';i=i+1)
            putchar(ipbuf[i]);
          lexflag=false;
          continue;
        }

        int n=searchdef(word);
        if(n!=-1){
          submacro=word;
          subarg=getArg();
          ipbuf=replacedef(submacro,subarg);
        }
        int i=0;
        for(i=0;ipbuf[i]!='\0';i=i+1)
          putchar(ipbuf[i]);
      }
      else if(type==T_EDEFINE){
        lexflag=false;
        putchar('\n');
        do_Edefine();
      }
      else if(type==T_SDEFINE){
        lexflag=false;
        putchar('\n');
        do_Sdefine();
      }
      else if(type==T_UNDEF){
        lexflag=false;
        putchar('\n');
        do_undef();
      }
      else if(type==T_INCLUDE){
        lexflag=false;
        do_include();
      }
    }
    else{
      lexflag=false;
      if(strCmp(word,"\n")==0)
        putchar('\n');
    }

    if(type==T_IFDEF){
      lexflag=false;
      condition=conditioncheck();
      do_ifdef(condition);
    }
    else if(type==T_ELSE){
      lexflag=false;
      do_else();
    }
    else if(type==T_IFNDEF){
      lexflag=false;
      condition=conditioncheck();
      do_ifndef(condition);
    }
    else if(type==T_ELSEIFDEF){
      lexflag=false;
      condition=conditioncheck();
      do_elseifdef(condition);
    }
    else if(type==T_ELSEIFNDEF){
      lexflag=false;
      condition=conditioncheck();
      do_elseifndef(condition);
    }
    else if(type==T_ENDIF){
      lexflag=false;
      do_endif();
    }

    if(feof(fd) && isp!=0){
      isp=deleteincdepth(incdepth[isp].name);
      fd=fopen(incdepth[isp].name,"r");
      fseek(fd,incdepth[isp].dbyteh,incdepth[isp].dbytel);
      byteh=incdepth[isp].dbyteh;
      bytel=incdepth[isp].dbytel;
      printf("h=%d l=%d\n",byteh,bytel);
    }
  }

  fclose(fd);
  puts(opname);
  return 0;
}
